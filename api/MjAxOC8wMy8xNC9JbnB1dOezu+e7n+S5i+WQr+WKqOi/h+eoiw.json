{"title":"Input 系统启动","date":"2018-03-14T02:22:46.000Z","date_formatted":{"ll":"Mar 14, 2018","L":"03/14/2018","MM-DD":"03-14"},"link":"2018/03/14/Input系统之启动过程","tags":["Android"],"categories":["笔记"],"updated":"2020-04-04T05:59:18.673Z","content":"<h5 id=\"介绍\">介绍<a title=\"#介绍\" href=\"#介绍\"></a></h5>\n<p>  当用户触摸屏幕或者按键操作，首次触发硬件驱动，驱动收到事件后，将该相应事件写入到输入设备节点，接着，输入系统取出原生态的事件，经过层层封装后成为 KeyEvent 或者 MotionEvent 。最后，交付给相应的目标窗口(Window)来消费该输入事件。可见，输入系统在整个过程起到承上启下的衔接作用。</p>\n<p>   Input 模块的作用如下:</p>\n<ul>\n<li>Native 层的 InputReader 负责从 EventHub 取出事件并处理，再交给 InputDispatcher</li>\n<li>Native 层的 InputDispatcher 接收来自 InputReader 的输入事件，并记录 WMS 的窗口信息，用于派发事件到合适的窗口</li>\n<li>Java 层的 InputManagerService 跟 WMS 交互，WMS 记录所有窗口信息，并同步更新到 IMS ，为 InputDispatcher 正确派发事件到 ViewRootImpl 提供保障</li>\n<li>Native 层的 InputReader 对象中含有一个类型为 QueueInputListener 的对象 mQueuedListener 。mQueuedListener 的内部类 mInnerListener 是和 InputDispatcher 通信的纽带。</li>\n</ul>\n<h5 id=\"启动过程\">启动过程<a title=\"#启动过程\" href=\"#启动过程\"></a></h5>\n<p>   IMS 服务是随着 system_server 进程的启动而启动的,所调用的方法的逻辑关系如下:</p>\n<pre><code>new InputManagerService(context)\n\tnativeInit(...)\n\t\tnew NativeInputManager(...)\n\t\t\tnew EventHub\n\t\t\tnew InputManager(...)\n\t\t\t\tnew InputDispatcher(...)\n\t\t\t\t\tnew Looper(false)\n\t\t\t\tInputReader(...)\n\t\t\t\t\tnew QueuedInputListener(...)\n\t\t\t\tinitialize()\n\t\t\t\t\tnew InputReaderThread(...)\n\t\t\t\t\tnew InputDispatcherThread(...)\nIMS.start()\n    nativeStart(mPtr)\n\t\tInputManager-&gt;start()\n\t\t\tInputReaderThread-&gt;run()\n\t\t\tInputDispatcherThread-&gt;run()\n</code></pre>\n<p>  InputManagerService 的初始化过程是通过<code>new InputManagerService(context)</code>，在 new 的过程中，首先有一个初始化 native 对象的过程，在这个过程中，首先会获取 native 消息队列，最后还需要创建 native 的 InputManager 对象。通过<code>new NativeInputManager(...)</code><br>\n创建 NativeInputManager 对象时，其实是根据上层 IMS 的 context 以及上层 IMS 对象来进行一些变量的赋值，同时在构造 NativeInputManager 对象时，还需要创建 EventHub 对象和 InputManager 对象。</p>\n<p>  在创建 EventHub 对象时，首先会创建 epoll 实例，并会初始化 INotify 来监听 /dev/input，并会将 INotify 添加到 epoll 实例。然后做的就是创建非阻塞模式的管道，并添加到 epoll 。</p>\n<p>  在 InputManager 类的构造函数中，会创建 InputDispatcher 对象和 InputReader 对象。</p>\n<p>  在 InputDispatcher 的构造函数中，会创建属于自己线程的 Looper 对象，接着获取分发超时参数，超时参数来自 IMS ，参数默认值 keyRepeatTimeout = 500， keyRepeatDelay = 50。</p>\n<p>  在创建 InputReader 对象的时候会传入一个已经创建好的 eventHub 对象，InputReader 的作用就是用来读取 EventHub 中的事件，从而传递给 InputDispatcher 的，在这里将 EventHub 对象传递到 InputReader 的有参构造方法中，以便 InputReader 能够取出 EventHub 中的事件。同时在 InputReader  的构造方法中，会创建输入监听对象<code>new QueuedInputListener(listener)</code>，这便是 InputReader 和 InputDispatcher 联系的纽带，通过 QueuedInputListener 内部成员变量 mInnerListener 指向 InputDispatcher 对象。这里的 listener 便是 InputDispatcher 对象。</p>\n<p>  创建好 InputReader 和 InputDispatcher 对象之后，接着就是执行 initialize 的过程，初始化的主要工作就是创建两个(InputReaderThread 和 InputDispatcherThread)能访问 Java 代码的 native 线程。到此处便是 InputManagerService 完成了对象的创建和初始化的过程，接下来便是调用其 start 方法。</p>\n<p>  在<code>IMS.start()</code>方法中，首先会通过<code>nativeStart(mPtr)</code>启动 native 对象，此处 ptr 记录的是 NativeInputManager 对象，通过 ptr 获取到 NativeInputManager 对象 im 后，通过<code>im-&gt;getInputManager()-&gt;start()</code>来启动，在<code>InputManager.start()</code>方法中，主要做的就是启动 InputReaderThread 和 InputDispatcherThread 两个线程。启动好 native 对象之后，接着使用<code>registerPointerSpeedSettingObserver()</code>注册触摸点速度的观察者，使用<code>registerShowTouchesSettingObserver()</code>注册是否显示功能的观察者，然后再注册广播，通过接受广播来更新触摸点速度以及确定是否在屏幕上显示触摸点。</p>\n","prev":{"title":"Input系统之UI线程","link":"2018/03/20/Input系统之UI线程"},"next":{"title":"Git使用总结","link":"2018/03/11/Git"},"plink":"https://zhoufeichi.com/2018/03/14/Input系统之启动过程/","reward":true}