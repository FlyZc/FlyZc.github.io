{"title":"Input系统之InputReader线程","date":"2018-03-30T02:01:33.000Z","date_formatted":{"ll":"Mar 30, 2018","L":"03/30/2018","MM-DD":"03-30"},"link":"2018/03/30/Input系统之InputReader线程","tags":["Android"],"categories":["笔记"],"updated":"2020-04-04T05:59:18.673Z","content":"<h5 id=\"获取事件\">获取事件<a title=\"#获取事件\" href=\"#获取事件\"></a></h5>\n<p>   InputReader 线程的执行过程从 threadLoop 开始，在<code>threadLoop()</code>中，会调用<code>loopOnce()</code>方法，同时会返回 true 。返回值 true 代表会不断的循环调用<code>loopOnce()</code>方法。进入到 loopOnce() 方法中，需要通过<code>mEventHub-&gt;getEvents</code>从 EventHub 中获取事件，在 EventHub 类的 getEvents 方法中，会有如下的操作过程，</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">getEvents</span>(...)</span><br><span class=\"line\">\t<span class=\"built_in\">scanDevicesLocked</span>()</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanDirLocked</span>(DEVICE_PATH)</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">openDeviceLocked</span>(devname)</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">addDeviceLocked</span>(device)</span><br></pre></td></tr></table></figure>\n<p>  那么从进入到<code>getEvents(...)</code>方法体中开始，如果需要扫描设备，那么则先会通过调用<code>scanDevicesLocked()</code>来扫描 DEVICE_PATH 为<code>/dev/input</code>的所有设备，在<code>scanDevicesLocked()</code>方法体内会进一步调用<code>scanDirLocked(DEVICE_PATH)</code>方法，在<code>scanDirLocked(...)</code>中，根据传进来的 DEVICE_PATH 路径，接下来要做的就是读取<code>/dev/input/</code>目录下所有的设备节点。读取到设备节点之后通过调用<code>openDeviceLocked(...)</code>方法来打开相应的设备节点，在<code>openDeviceLocked(...)</code>方法中需要处理以下事件:</p>\n<ul>\n<li>打开设备文件 <code>fd = open(devicePath, ...)</code></li>\n<li>获取设备名</li>\n<li>获取设备物理地址</li>\n<li>获取设备唯一ID uniqueId</li>\n<li>将获取到的设备名、设备物理地址、唯一 ID 等这些 identifier 信息填充到刚开始打开的设备文件中</li>\n<li>设置 fd 为非阻塞方式</li>\n<li>获取设备Id(deviceId)，为设备对象分配内存空间<code>device = new Device(...)</code></li>\n<li>注册 epoll</li>\n<li>调用 addDeviceLocked(device)，该方法的作用就是将 device 添加到 mDevices 队列，同时将 device 对象赋值给 mOpeningDevies。</li>\n</ul>\n<h5 id=\"处理事件\">处理事件<a title=\"#处理事件\" href=\"#处理事件\"></a></h5>\n<p>  前面便是 EventHub 已经完成了从设备节点获取事件并将事件封装成 RawEvent 的过程，获取事件之后会通过调用<code>InputReader::processEventsLocked(...)</code>方法来处理事件，也会根据事件的类型来进行一些设备增删等操作，</p>\n<ul>\n<li>DEVICE_ADDED: 设备增加</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">addDeviceLocked</span>(...)</span><br><span class=\"line\">\t<span class=\"built_in\">createDeviceLocked</span>(...)</span><br><span class=\"line\">\tmDevices.<span class=\"built_in\">add</span>(deviceId, device)</span><br></pre></td></tr></table></figure>\n<p>  在<code>createDeviceLocked(...)</code>方法的作用就是创建并获得一个 InputDevice 对象，那么在这个方法中首先就是创建了一个 InputDevice 对象，将 InputReader 的 mContext 赋值给 InputDevice 对象所对应的变量。然后需要根据设备类型来创建并添加相应的 InputMapper ，同时设置 mContext 。 input 设备类型有常见的以下几种：</p>\n<blockquote>\n<p>键盘类设备：KeyboardInputMapper\t\t<br>\n触摸屏设备：MultiTouchInputMapper 或 SingleTouchInputMapper\t\t<br>\n鼠标类设备：CursorInputMapper</p>\n</blockquote>\n<ul>\n<li>DEVICE_REMOVED: 设备移除</li>\n<li>FINISHED_DEVICE_SCAN: 设备扫描完成</li>\n</ul>\n<p>  除了设备的增删这些事件的操作，事件的处理是通过<code>processEventsForDeviceLocked(...)</code>方法来实现，</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">processEventsForDeviceLocked</span>(...)</span><br><span class=\"line\">\tdevice-&gt;<span class=\"built_in\">process</span>(...)</span><br><span class=\"line\">\t\tmapper-&gt;<span class=\"built_in\">process</span>(rawEvent)</span><br></pre></td></tr></table></figure>\n<p>  在<code>processEventsForDeviceLocked(...)</code>方法中，需要先获得 InputDevice 对象 device ，然后通过调用<code>device-&gt;process(...)</code>来进一步处理。最终也是根据不同的 InputMapper 种类来处理不同的按键事件。比如对于键盘类设备，调用的是 KeyboardInputMapper 类中的<code>process()</code>方法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapper-&gt;<span class=\"built_in\">processs</span>(...)</span><br><span class=\"line\">\t<span class=\"built_in\">getEventHub</span>()-&gt;<span class=\"built_in\">mapKey</span>(...)</span><br><span class=\"line\">\t\tKeyCharacterMap-&gt;<span class=\"built_in\">mapKey</span>(...)</span><br><span class=\"line\">\tInputMapper.<span class=\"built_in\">processKey</span>(...)</span><br><span class=\"line\">\t\t <span class=\"built_in\">getListener</span>()-&gt;<span class=\"built_in\">notifyKey</span>(...)</span><br></pre></td></tr></table></figure>\n<p>  在<code>process()</code>方法中，首先就是需要获取 keyCode ，然后再是<code>processKey(...)</code>的过程。在这个过程中，判断是键盘是按下还是抬起，并获取相应的 keyCode 事件，根据获取到的 keyCode 等信息最终需要通知 key 事件，此处 KeyboardInputMapper 的 mContext 指向 InputReader，还需要做的事情就是将这些按键事件封装到 NotifyKeyArgs 对象 args 中，<code>getListener()</code>获取的便是 mQueuedListener 。 接下来调用该对象的 <code>QueuedInputListener::notifyKey(...)</code>方法，在这个<code>notifyKey(...)</code>方法中，会将该 key 事件压入类型为 Vector&lt;NotifyArgs*&gt;栈顶，接下来要做的就是将事件发送给 InputDispatcher 线程。</p>\n<h5 id=\"发送事件\">发送事件<a title=\"#发送事件\" href=\"#发送事件\"></a></h5>\n<p>  <code>processEventsLocked()</code>是对事件进行加工的过程，将 RawEvent 转换成<code>NotifyKeyArgs(NotifyArgs)</code>。执行完<code>processEventsLocked()</code>后，需要通过<code>mQueuedListener-&gt;flush()</code>来实现将事件发送给 InputDispatcher 线程。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">flush</span>()</span><br><span class=\"line\">\targs-&gt;<span class=\"built_in\">notify</span>(mInnerListener)</span><br><span class=\"line\">\t\tmInnerListener-&gt;<span class=\"built_in\">notifyKey</span>(<span class=\"keyword\">this</span>)  <span class=\"comment\">// this是指NotifyKeyArgs</span></span><br><span class=\"line\">\t\t\tevent.<span class=\"built_in\">initialize</span>(...)\t<span class=\"comment\">//初始化 KeyEvent 对象</span></span><br><span class=\"line\">\t\t\tmPolicy-&gt;<span class=\"built_in\">interceptKeyBeforeQueueing</span>(...)</span><br><span class=\"line\">\t\t\tmPolicy-&gt;<span class=\"built_in\">filterInputEvent</span>(...)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">new</span> <span class=\"built_in\">KeyEntry</span>(...)\t<span class=\"comment\">//创建 KeyEntry 对象</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">enqueueInboundEventLocked</span>(newEntry)</span><br><span class=\"line\">\t\t\tmLooper-&gt;<span class=\"built_in\">wake</span>()\t <span class=\"comment\">//唤醒 InputDispatcher 线程</span></span><br></pre></td></tr></table></figure>\n<p>  我们知道前面处理的是 KeyCode 相关的事件，因此此处的 args 是 NotifyKeyArgs 对象， mInnerListener 是 InputDispatcher 类型， mPolicy 是指 NativeInputManager 对象。调用<code>NativeInputManager.interceptKeyBeforeQueueing(...)</code>方法在加入队列前执行拦截动作时会调用 Java 层的<code>InputManagerService.interceptKeyBeforeQueueing()</code>方法。当 mInputFilterEnabled = true(该值默认为false,可通过 setInputFilterEnabled 设置),则调用<code>NativeInputManager.filterInputEvent(...)</code>过滤输入事件。</p>\n<p>  在<code>enqueueInboundEventLocked(newEntry)</code>方法中，EventEntry 类型为 TYPE_MOTION ，那么需要执行<code>findTouchedWindowAtLocked(...)</code>来查找可触摸窗口。最后执行完如果满足下列条件，那么则需要唤醒 InputDispatcher 线程。</p>\n<ul>\n<li>执行<code>enqueueInboundEventLocked(...)</code>方法前， mInboundQueue 队列为空,执行完必然不再为空,则需要唤醒分发线程</li>\n<li>当事件类型为 key 事件，且发生一对按下和抬起操作,则需要唤醒</li>\n<li>当事件类型为 motion 事件，且当前可触摸的窗口属于另一个应用，则需要唤醒</li>\n</ul>\n<p>  那么<code>QueuedListener_flush()</code>的过程就是将事件发送到 InputDispatcher 线程，转换 NotifyKeyArgs 为 KeyEntry。</p>\n<p>   InputReader 线程不断循环的执行<code>InputReader.loopOnce()</code>，每次从 EventHub 获取数据后生成 EventEntry ，最后再交给 InputDispatcher 线程处理。</p>\n","prev":{"title":"Input系统之InputDisptcher线程","link":"2018/03/30/Input系统之InputDisptcher线程"},"next":{"title":"Input系统之UI线程","link":"2018/03/20/Input系统之UI线程"},"plink":"https://zhoufeichi.com/2018/03/30/Input系统之InputReader线程/","reward":true,"reading_time":"1230 words in 8 min"}