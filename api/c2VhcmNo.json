[{"title":"Hive 1.2.2环境搭建","date":"2022-02-02T12:09:16.000Z","date_formatted":{"ll":"Feb 2, 2022","L":"02/02/2022","MM-DD":"02-02"},"updated":"2022-02-02T13:10:27.472Z","content":"安装包准备\n\napache-hive-1.2.2-bin.tar.gz\nmysql-connector-java-5.1.49.tar.gz\njline-2.12.jar\n\n解压apache-hive-1.2.2-bin.tar.gz(master)\n\ncd /usr/local/src\ntar -zxvf apache-hive-1.2.2-bin.tar.gz\n\n修改Hive配置信息(master)\n\ncd apache-hive-1.2.2-bin/conf\nvim hive-site.xml\n\n123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;&lt;configuration&gt;        &lt;property&gt;                &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;                &lt;value&gt;jdbc:mysql://master:3306/hive?createDatabaseIfNotExist=true&amp;amp;useSSL=false&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;                &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;                &lt;value&gt;root&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;                &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;                &lt;value&gt;123456&lt;/value&gt;        &lt;/property&gt;        &lt;property&gt;               &lt;name&gt;hive.metastore.warehouse.dir&lt;/name&gt;                                        &lt;value&gt;/user/hive/warehouse&lt;/value&gt;       &lt;/property&gt;       &lt;property&gt;             &lt;name&gt;yarn.app.mapreduce.am.command-opts&lt;/name&gt;             &lt;value&gt;-Djava.net.preferIPv4Stack=true -Xmx500m&lt;/value&gt;       &lt;/property&gt;       &lt;property&gt;             &lt;name&gt;mapreduce.map.java.opts&lt;/name&gt;             &lt;value&gt;-Djava.net.preferIPv4Stack=true -Xmx500m&lt;/value&gt;       &lt;/property&gt;       &lt;property&gt;            &lt;name&gt;mapreduce.reduce.java.opts&lt;/name&gt;            &lt;value&gt;-Djava.net.preferIPv4Stack=true -Xmx500m&lt;/value&gt;       &lt;/property&gt;&lt;/configuration&gt;\n\nvim hive-env.sh\n\n123456# Set HADOOP_HOME to point to a specific hadoop install directoryexport HADOOP_HOME=/usr/local/src/hadoop-2.7.7# Hive Configuration Directory can be controlled by:export HIVE_CONF_DIR=/usr/local/src/apache-hive-1.2.2-bin/conf# Folder containing extra libraries required for hive compilation/execution can be controlled by:export HIVE_AUX_JARS_PATH=/usr/local/src/apache-hive-1.2.2-bin/lib\n添加环境变量(master,slave1,slave2)\n\nvim ~/.bashrc\n\n12export HIVE_HOME=/usr/local/src/apache-hive-1.2.2-binexport PATH=$PATH:$HIVE_HOME/bin\n\nsource ~/.bashrc\n\n安装MySQL\n安装MySQL连接工具(master)\n\n将mysql-connector-java-5.1.45-bin.jar放入/usr/local/src/apache-hive-1.2.2-bin/lib\n将jline-2.12.jar放入/usr/local/src/hadoop-2.7.7/share/hadoop/yarn/lib(master，slave1,slave2均设置)\n\nslave节点配置\n\nscp -r /usr/local/src/apache-hive-1.2.2-bin root@slave1:/usr/local/src/apache-hive-1.2.2-bin\nscp -r /usr/local/src/apache-hive-1.2.2-bin root@slave2:/usr/local/src/apache-hive-1.2.2-bin\n\n启动Hive\n","plink":"https://zhoufeichi.com/2022/02/02/Hive-1-2-2环境搭建/"},{"title":"Centos 7.6安装Mysql","date":"2022-01-25T13:27:28.000Z","date_formatted":{"ll":"Jan 25, 2022","L":"01/25/2022","MM-DD":"01-25"},"updated":"2022-02-02T13:10:56.616Z","content":"安装mysql服务\n\nwget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm\nyum -y install mysql57-community-release-el7-10.noarch.rpm\nyum -y install mysql-community-server\n如果安装过程中出现如下类似信息：\n\n\nFailing package is: mysql-community-libs-compat-5.7.37-1.el7.x86_64\nGPG Keys are configured as: file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql\n\n\n更新GPG\n\nrpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022\n\n\n\n启动mysql服务\n\nsystemctl start  mysqld.service\n设置mysql开机自启\n\nsystemctl enable mysqld\n\n\n查看mysql状态\n\nsystemctl status mysqld.service\n\n\n查看mysql临时密码\n\ngrep &quot;password&quot; /var/log/mysqld.log\n\n\n登陆mysql\n\nmysql -uroot -p\n\n\n修改mysql密码\n\nset global validate_password_policy=0;\nset global validate_password_length=1;\nalter user 'root'@'localhost' identified by '123456';\n\n\n配置用户权限及授权\n\ngrant all on *.* to 'root'@'%' identified by '123456';\ngrant all on *.* to 'root'@'localhost' identified by '123456';\ngrant all on *.* to 'root'@'master' identified by '123456';\nflush privileges;\n\n\n取消自动更新\n\nyum -y remove mysql57-community-release-el7-10.noarch\n\n\n\n","plink":"https://zhoufeichi.com/2022/01/25/Centos-7-6安装Mysql/"},{"title":"VMware安装Hadoop环境","date":"2022-01-24T14:32:39.000Z","date_formatted":{"ll":"Jan 24, 2022","L":"01/24/2022","MM-DD":"01-24"},"updated":"2022-01-25T07:13:18.201Z","content":"配置Master节点环境\n\n\n配置IP信息\nvi /etc/sysconfig/network-scripts/ifcfg-ens33\n\n\n\n虚拟机NAT设置\n\n\n\n虚拟机DHCP设置\n\n\n\n重启网络\nsystemctl restart network\n\n\n配置host信息\n12345vim /etc/hosts192.168.159.19 master192.168.159.20 slave1192.168.159.21 slave2\n\n\n配置network\n123vim /etc/sysconfig/networkNETWORKING=yesHOSTNAME=masterr\n\n\n配置hostname\n12vim /etc/hostnameMaster\n\n\n关闭网络管理\nsystemctl stop NetworkManager\nsystemctl disable NetworkManager\n\n\n关闭linux内核防火墙\n12vim /etc/selinux/configSELINUX=disable\n\n\n内核防火墙置空\nsetenfore 0\n\n\n关闭防火墙\nsystemctl stop firewalld\nsystemctl disable firewalld\n\n\n配置hadoop和jdk环境\n12345678910111213vim ~/.bashrcexport JAVA_HOME=/usr/local/src/jdk1.8.0_172export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/libexport HADOOP_HOME=/usr/local/src/hadoop-2.7.7export M2_HOME=/opt/apache-maven-3.5.4export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbinexport HADOOP_OPTS=&quot;-Djava.library.path=$&#123;HADOOP_HOME&#125;/lib/native&quot;export PATH=$PATH:$M2_HOME/binexport FINDBUGS_HOME=/opt/findbugs-3.0.1export PATH=$PATH:$FINDBUGS_HOME/binexport HIVE_HOME=/usr/local/src/apache-hive-1.2.2-binexport PATH=$PATH:$HIVE_HOME/bin\n\n\n覆盖hadoop目录etc/hadoop下列文件\n\ncore-site.xml\nhdfs-site.xml\nmapred-site.xml\nslaves\nyarn-site.xml\n\n\n\n配置Slave节点环境\nmaster配置完毕后，拷贝镜像文件分别配置slave1和slave2，并修改以下参数信息\n\nvi /etc/sysconfig/network-scripts/ifcfg-ens33\nvim /etc/sysconfig/network\nvim /etc/hostname\nsystemctl restart network\n\n配置三台设备互信\n\nssh-keygen -t rsa\ncat /root/.ssh/id_rsa.pub &gt; /root/.ssh/authorized_keys\nssh master cat /root/.ssh/authorized_keys &gt;&gt; /root/.ssh/authorized_keys\n\n磁盘格式化\n\nhadoop namenode -format\n\n故障处理\n如果集群出错，先停止集群进程，三台设备均删除相关文件后重新进行磁盘格式化\n\nstop-all.sh\nrm -rf /dfs /logs /tmp\nhadoop namenode -format\n\n","plink":"https://zhoufeichi.com/2022/01/24/VMware安装Hadoop环境/"},{"title":"617-Merge Two Binary Trees","date":"2020-06-07T19:00:17.000Z","date_formatted":{"ll":"Jun 8, 2020","L":"06/08/2020","MM-DD":"06-08"},"updated":"2022-01-25T07:10:30.708Z","content":"Description\nGiven two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.\nYou need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.\nExample 1:\n\nNote: The merging process must start from the root nodes of both trees.\nCode\n12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123;        if (t1 == null)            return t2;        Stack &lt; TreeNode[] &gt; stack = new Stack &lt; &gt; ();        stack.push(new TreeNode[] &#123;t1, t2&#125;);        while (!stack.isEmpty()) &#123;            TreeNode[] t = stack.pop();            if (t[0] == null || t[1] == null) &#123;                continue;            &#125;            t[0].val += t[1].val;            //right first            if (t[0].right == null) &#123;                t[0].right = t[1].right;            &#125; else &#123;                stack.push(new TreeNode[] &#123;t[0].right, t[1].right&#125;);            &#125;            //left            if (t[0].left == null) &#123;                t[0].left = t[1].left;            &#125; else &#123;                stack.push(new TreeNode[] &#123;t[0].left, t[1].left&#125;);            &#125;        &#125;        return t1;    &#125;&#125;\n","plink":"https://zhoufeichi.com/2020/06/08/617-Merge-Two-Binary-Trees/"},{"title":"ICMP 协议解析","date":"2020-02-20T09:25:06.000Z","date_formatted":{"ll":"Feb 20, 2020","L":"02/20/2020","MM-DD":"02-20"},"updated":"2022-01-25T08:07:51.586Z","content":"ICMP协议介绍\n在日常工作中，我们通常会用到 ping、tracert(traceroute)命令来检测网络链路状况和跟踪路由。Ping 和 tracert(traceroute)是基于 ICMP 协议工作的，我们首先来了解 ICMP 到底是什么？\nICMP(Internet Control Message Protocol)，因特网控制报文协议，它的作用就是确认IP包是否成功送达目标地址，如果某个 IP 包未能达到目标地址，则会通过ICMP包告知IP数据包传输失败的原因。ICMP 报文封装到 IP 数据包里进行传输，不经过传输层，但我们通常认为 ICMP 协议是 IP 层的附属协议，属于网络层的协议。ICMP 的报文格式如下：\n \n在 ICMP 首部格式中，类型字段(8为)大致标识了两种不同 ICMP 类型，常见类型的标识如下所示：\n\n查询报文类型，用于诊断的查询信息\n\n0:回送应答(Echo Reply)\n8:回送请求(Echo Request)\n\n\n差错报文类型，用于通知出错原因的错误消息\n\n3:目标不可达(Destination Unreachable)\n4:原点抑制(Source Quench)\n5:重定向或改变路由(Redirect)\n11:超时(Time Exceeded)\n\n\n\n查询报文两种类型的回送消息常用于判断通信的主机或路由器之间，所发送的数据包是否已经成功到达对端，发送端构造回送请求消息并发送给目标主机，目标主机接收到回送请求消息后，如果正常返回回送应答消息，那么发送端到接收端之间是可达的。\n再看几种典型的差错报文类型：\n\n 目标不可达:3\n当路由器无法将IP数据包发送给目标地址时，会给发送端主机返回一个目标不可达的 ICMP 消息，结合 ICMP 首部格式中的代码字段告知发送端不可达的具体原因。\n\n常见的不可达原因有：\n\n0：网络不可达（Network Unreachable）\n\n通常情况下，当路由器中的路由器表匹配不到 IP 的网络号时，就会通过 ICMP 消息告知发送端主机“网络不可达”。\n\n\n1：主机不可达（Host Unreachable）\n\n通常情况下，当路由表中没有该主机的信息，或者该主机没有连接到网络中，路由器就会通过 ICMP 消息告知发送端主机“主机不可达”。\n\n\n2：协议不可达（Protocol Unreachable)\n\n当主机以某种协议访问对端主机时，如果对端主机的防火墙已经禁止该协议进行访问，那么会通过 ICMP 消息告知发送端主机“协议不可达”。\n\n\n3：端口不可达（Port Unreachable）\n\n当主机访问对端主机端口 A 时，此时对端主机并没有进程监听 A 端口，那么会通过 ICMP 消息告知发送端主机“端口不可达”。\n\n\n4：数据包太大需要分片但不允许分片（Fragmentation needed but no frag）\n\n路由器在转发数据包的过程中，若数据包的大小超过 MTU，继续转发数据包，需要将数据包进行分片，此时如果数据包首部的 DF(Don’t Fragment) 字段为 1 ，那么路由器会直接丢弃该数据包，通过 ICMP消息告知发送端主机数据发送失败的原因为数据包太大需要分片但不允许分片。\n\n\n\n\n 原点抑制:4\n当链路发送拥塞时，通过向发送端主机发送原点抑制消息告知主机链路发生了拥堵的情况，从而增大数据包发送的时间间隔，达到减少网络拥堵的目的。\n 重定向消息:5\n如果路由器发现发送端主机使用了「不是最优」的路径发送数据，那么它会返回一个 ICMP 重定向消息告知主机更合适的路由信息。\n 超时消息:11\n从IP数据包首部格式中我们可以看到有个TTL(Time to Live)的字段，每经过一次路由器，它的值就会减1，直到减到0时，该数据包就会被丢弃，此时路由器就会发送一个ICMP 超时消息通知发送端主机该数据包已被丢弃。\n设置 TTL 的主要目的，是为了避免在路由环路的情况下，IP 包无休止地在网络上被转发。\n\nping命令工作过程\n现有主机A（192.168.0.1）和主机B（192.168.0.2），我们在主机A上输入命令：ping 192.168.0.2之后：\n主机A构建一个 ICMP回送请求消息数据包。ICMP 首部的类型字段会设置为 8，代表回送请求消息类型；序号字段则是用于区分连续发送 ping 命令时的不同数据包，每发出一个请求数据包，序号会加 1。在报文的数据部分也不会添加发送时间，用于计算往返时间 RTT。\n然后 ICMP协议会将这个数据包以及目标IP（192.168.0.2）等信息一同交给IP层处理。IP层协议得到这些信息后，将源地址（即本机IP）、目标地址（即目标IP：192.168.0.2）、协议字段(1)，以及其它的控制信息，构建成一个IP数据包。\nIP数据包构建完成后，再交给数据链路层处理，加上 MAC 首部。此时本地 ARP 映射表中若包含目标 IP (192.168.0.2)的映射关系，那么直接取出对应的 MAC 地址并添加到 MAC 首部目的 MAC 字段。若映射表中不包含目标IP，则需要发送 ARP 查询 MAC 地址，获得 MAC 地址后，再构建链路层的数据帧。\n当主机B收到这个数据帧之后，会首先检查它的目标MAC地址是不是本机，如果是就接收下来处理，将数据帧中的 IP 数据包取出来，交给本机的IP层协议，然后IP层协议检查完之后，再将 ICMP 数据包取出来交给 ICMP 协议处理，当这一步处理完成之后，就会构建一个 ICMP 回送响应数据包，ICMP 首部的类型字段会设置为 0，序号字段设置为接收到的请求数据包中的序号，然后回送给主机A。\n在一定的时间内，如果主机A收到了应答包，则说明它与主机B之间网络可达，如果没有收到，则说明网络不可达。源主机根据接收到的应答数据包的时间和发送请求数据包的时间计算出ICMP 数据包的时间延迟。\n如果两台主机不在同一个网段，那么还会涉及到网关、路由器的转发，但是 ICMP 消息的构造依旧是不变的，路由器将数据包转发另一个网段时需要修改 MAC 帧首部源 MAC 地址字段的值。可以看出，在整个 ping 程序的执行过程中使用了 ICMP 里面的 ECHO REQUEST（回送请求：8 ） 和 ECHO REPLY （回送应答：0）两种报文类型。\nPing 命令案例分析\nLocalhost、127.0.0.1和本机ip的区别\n我们通过 Ping 程序来检测本机到目标主机的网络状况，在构建 IP 包的过程中，我们需要将本机 IP 地址设置为源IP，在现实场景中，我们经常也会看到 localhost, 127.0.0.1，这与本机 IP 又有何联系，如果我们分别 ping localhost 和 127.0.0.1又会是什么样呢？继续往下分析。\n首先我们来 ping localhost:\n \n从图中可以看出，ping localhost的过程中，会解析成 ping 127.0.0.1，这是因为 localhost 是一个域名，从hosts 文件中可以看出，这个域名是预定义的，它默认指向的是 127.0.0.1 这个 IP 地址。\n127.0.0.1 被称作环回地址，它是主机用于向自身发起通信的一个特殊地址，包含环回地址的IP数据包不会到达外部网络接口，离开主机的包，也就是说：IP 数据包不会通过数据链路层，物理层，以太网传出去，而是可以直接在自己的网络层，运输层进行处理。当操作系统初始化本机的TCP/IP协议栈时，设置协议栈本身的IP地址为127.0.0.1（保留地址），并注入路由表。当IP层接收到目的地址为127.0.0.1的数据包时，不调用网卡驱动进行二次封装，而是立即转发到本机IP层进行处理，当我们禁用网卡后，ping 127.0.0.1也是能 ping 通的。\n \n通过抓包我们可以看到 ping 过程中ICMP Echo Request 消息和 ICMP Echo Reply消息的交互过程，查看数据包内容可以看到ICMP报文首部字段以及IP数据包首部字段的数据：\n \nIP 数据包中协议字段通过设置为 1 来标识 ICMP 协议，同事设置源地址和目的地址都为 127.0.0.1，在ICMP 首部格式中，设置类型来区分回送应答以及回送请求，不管是回送应答的报文还是回送请求的报文，代码(Code)字段都设置为 0。\n最后我们再来看本地 IP 地址，通常情况下，“本机IP地址”指的是“本机物理网卡所绑定的网络协议地址”。我们 ping 本地 IP，通过抓包可以看到，只能在环回接口抓到相应的数据包，所以数据包同样不会通过网卡转发出去，但是如果禁用网卡，这时驱动程序未能获得本地主机IP，再 ping 本地 IP，我们可以看到会有“PING:传输失败。常见故障”的提示信息。\nTraceroute/Tracert 命令工作过程\nTraceroute\n前面我们讲到 ping 命令用到 ICMP 中的查询报文来检测链路的状况，而 traceroute 命令则是利用了 ICMP 差错报文来实现。我们通过 wireshark 抓包来分析路由跟踪的整个过程，\n \n源主机通过 traceroute 追踪路由时，首先会构造 UDP 报文段，并通过 IP 数据包封装。\n \n在 IP 数据包首部会设置特殊的TTL值，来追踪源主机和目标主机之间的路由。首先它给目标主机发送一个 TTL=1 的数据包，那么这个数据包一旦在路上遇到一个路由器，TTL就变成了0（TTL规则是每经过一个路由器都会减1），因为TTL=0了，所以路由器就会把这个数据包丢掉，然后产生一个错误类型（超时:11）的 ICMP 报文回发给源主机。这个时候源主机就拿到了第一个路由节点相关信息了。\n \n接着，源主机再给目标主机发一个 TTL=2 的数据包，依旧上述流程走一遍，就知道第二个路由节点的IP和耗时情况等信息。如此反复进行，traceroute 就可以拿到从主机A到主机B之间所有路由器的信息了。\n你可能会有疑问，数据包到达目标主机时，此时 TTL 的值应该为 1，那此时目标主机应该怎么回复源主机？在源主机构造 UDP 报文段的时候，会设置一个完全无法到达的目的端口号(大于30000)，那么此时目标主机会返回给源主机端口不可达的 ICMP 差错报文。当源主机收到差错报文类型是端口不可达时，说明发送方发出探测包到达了目标主机。从抓包数据中我们也可以看出，一条路径上的每个设备 traceroute 要测3次，我们可以得到每次测试的传输时延等信息。\n \nTracert\n与 traceroute 不同的地方是，tracert 通过构造 ICMP 查询报文类型来跟踪源地址到目的地址的路由。\n \n源主机首先向目的地址发出一个ICMP回送请求（ICMP Echo request）数据包，并将TTL设置为1，经过路由器时，TTL会被减1。当TTL变为0时，包被丢弃，路由器向源地址发回一个ICMP超时通知（ICMP Time Exceeded Message），内含发送IP包的源地址，IP包的所有内容及路由器的IP地址。当源地址收到该ICMP包时，显示这一跳路由信息。\n接着，源主机再给目标主机发一个 TTL=2 的数据包，依旧上述流程走一遍，就知道第二个路由节点的IP和耗时情况等信息。如此反复进行，直至目标地址收到探测数据包，并返回ICMP回应答复（ICMPEcho Reply），当源地址收到ICMP Echo Reply包时停止 tracert，这样便拿到从主机A到主机B之间所有路由器的信息。\n","plink":"https://zhoufeichi.com/2020/02/20/NetworkKnowleges1/"},{"title":"406.Queue Reconstruction by Height","date":"2020-02-10T13:57:33.000Z","date_formatted":{"ll":"Feb 10, 2020","L":"02/10/2020","MM-DD":"02-10"},"updated":"2022-01-25T02:24:01.637Z","content":"Description\nSuppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.\nNote:\nThe number of people is less than 1,100.\nExample:\nInput:\n[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]\nOutput:\n[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]\nCode\n123456789101112131415161718class Solution &#123;    public int[][] reconstructQueue(int[][] people) &#123;    Arrays.sort(people, new Comparator&lt;int[]&gt;() &#123;        @Override        public int compare(int[] a, int[] b) &#123;            if (a[0] != b[0]) &#123;                return b[0] - a[0];            &#125;        return a[1] - b[1];        &#125;    &#125;);    List&lt;int[]&gt; result = new LinkedList&lt;&gt;();    for(int[] p : people)&#123;        result.add(p[1], p);    &#125;    return result.toArray(new int[people.length][]);&#125;\n","plink":"https://zhoufeichi.com/2020/02/10/406-Queue Reconstruction by Height/"},{"title":"1.TwoSum","date":"2019-07-28T13:57:33.000Z","date_formatted":{"ll":"Jul 28, 2019","L":"07/28/2019","MM-DD":"07-28"},"updated":"2020-08-30T14:29:20.763Z","content":"Description\nGiven an array of integers, return indices of the two numbers such that they add up to a specific target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nExample:\nGiven nums = [2, 7, 11, 15], target = 9,\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].\nCode\n12345678910111213141516class Solution &#123;    public int[] twoSum(int[] nums, int target) &#123;        int[] index = &#123;-1, -1&#125;;        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(nums.length);        for (int i = 0; i &lt; nums.length; i++) &#123;            int other = target - nums[i];            if (map.containsKey(other) &amp;&amp; map.get(other) != i) &#123;                index[0] = i &lt; map.get(other) ? i : map.get(other);                index[1] = i &gt; map.get(other) ? i : map.get(other);                return  index;            &#125;            map.put(nums[i], i);        &#125;        return index;    &#125;&#125;\n","plink":"https://zhoufeichi.com/2019/07/28/1-TwoSum/"},{"title":"Linux基础","date":"2018-12-24T06:27:32.000Z","date_formatted":{"ll":"Dec 24, 2018","L":"12/24/2018","MM-DD":"12-24"},"updated":"2020-04-04T05:59:18.673Z","content":"基础命令\n\ntype：判断是内部命令还是外部命令\nman：外部命令\nhelp：内部命令\nyum -y install 目标软件：安装目标软件\nps -fe：打开进程列表\necho $$：查看当前 shell 的 pid\ndf -h：查看挂载分区，磁盘使用情况\ndu -h：查看文件或者文件夹的大小\nls -a：显示隐藏文件\nls -l：显示文件的详细信息\nmount /dev/cdrom /mnt：将/dev/cdrom 磁盘空间挂载到 /mnt 目录\ncd：回到 home 目录\ncd /：回到 根目录\npwd：显示当前工作目录\nrm -r -f a：删除文件夹 a\ncp -r a b：拷贝文件夹 a 到 b\nmv 123 123.bak：重命名\nmkdir -p a/b/c：创建多层目录\nvim +3 profile：打开profile文件，并定位到第3行\nvim +/PATTERN profile：打开profile文件，并定位到第一次被 PATTERN 匹配到的行的行首\no：在当前光标所在行的下方新建一行，并转为输入模式\nO：在当前光标所在行的上方新建一行，并转为输入模式\nI：在当前光标所在行的行首，转换为输入模式\nA：在当前光标所在行的行尾，转换为输入模式\nw：移至下一个单词的词首\ne：跳至当前或下一个单词的词尾\nb：跳至当前或前一个单词的词首\n0：移至行首\n$：移至行尾\n^：移至本行第一个非空白字符\nG：文章末尾\n3G：第三行\ngg：文章开头\nctrl + f/b：向前/后翻屏\nx：删除光标位置字符\n3x：删除光标开始3个字\nr：替换光标位置字符\ndd：删除整行，剪切\ndw：删除单词\nyy：复制整行\nyw：复制单词\np：粘贴至光标所在的下一行\nP：粘贴至光标所在的上一行\nu：撤销\nctrl + r：重做撤销的操作\n.：重做上一步的操作\n在末行模式下，/用来查找，n 向下翻，N 向上翻，! 可以用来执行命令，如 vi a.profile，编辑一个配置文件时，如果要配置的路径忘了，这个时候可以通过! ls -l /usr/来查看安装路径，这个时候不用保存退出，查到相关路径之后可以继续进入编辑\n删除文件所有内容，首先 gg 将光标定位到内容篇首\n\n.,$d（1,$-2d表示从第一行删除到倒数第二行）\ndG\n\n\n3,9 y：复制第三到第九行的内容(第一行标号是1)\n在 normal 模式下，按 v,然后移动光标hjkl选中内容后，可以按 &gt; 或者 &lt; 完成缩进和反缩进\ncut：显示切割的行数据\n\n-f1,2,3…或者 -f1-3：选择显示的列\n-s：不显示没有分隔符的行\n-d’分隔符’：自定义分隔符\n\n\nsort：给文件中的行排序\n\n-n：按数值排序，默认是按照字典序排序\n-r：倒序\n-t：自定义分隔符\n-k：选择排序列，和 -t 结合使用\n-u：合并相同行\n-f：忽略大小写\n\n\n\n","plink":"https://zhoufeichi.com/2018/12/24/Linux基础/"},{"title":"调试","date":"2018-09-20T12:20:11.000Z","date_formatted":{"ll":"Sep 20, 2018","L":"09/20/2018","MM-DD":"09-20"},"updated":"2020-04-04T05:59:18.673Z","content":"常用命令\n\nadb logcat -b events：打印系统事件的日志，跟踪系统事件的时候常用adb logcat -b events | grep am_\n\n","plink":"https://zhoufeichi.com/2018/09/20/调试/"},{"title":"常用快捷键记录","date":"2018-06-14T08:44:22.000Z","date_formatted":{"ll":"Jun 14, 2018","L":"06/14/2018","MM-DD":"06-14"},"updated":"2022-03-14T09:23:19.514Z","content":"IDEA\n\niter  自动补全foreach()\nitar  自动补全for()\nCtrl + Alt + M  选中要封装的代码,就会自动将该段代码封装成一个方法\nCtrl + D  将光标所在行代码复制到下一行\nCtrl + Y  删除光标所在行代码\nCtrl + Shift + /  注释选中的代码块\nCtrl + /  注释选中的代码块\nAlt + Insert  如果光标在项目的文件夹上，可以在当前文件夹中添加类,包等\nAlt + Insert   如果光标在类中（也就是是在项目的代码部分）,可以将构造函数,get,set等方法添加到该类中\nShift + F6  统一修改命名\nShift + Tab  选中的代码块向前缩进\nCtrl + Q  查看方法的使用说明\n长按Ctrl  鼠标放到方法上可以简要查看方法的使用方法\nCtrl + Alt + F  将变量提升为全局变量\nCtrl + Alt + V  将变量提升为局部变量\n\nSublime Text\n\nAlt 显示顶端导航栏\nCtrl + K + B 显示/隐藏左侧目录导航栏\n\nVisual Studio Code\n\nCtrl + B  显示/隐藏左侧目录导航栏\n\nVim\n\n:new 文件名  新建文件\n:e 文件名  打开文件\n:w 文件名  保存文件\n:wq  强制性写入文件并退出，即使文件没有被更改也强制写入，同时也会更新文件的修改时间\n:x  写入文件并退出，文件没有被更改时，不会被强制写入，也不会更新文件的修改时间，文件被更改时，才会更新文件的修改时间\n\nAndroid Studio\n\nCtrl + O  重写方法\n\nGit\n\ngit status  查看项目状态，会提示目前项目中修改过的信息\ngit diff  查看项目中文件更改的内容\ngit checkout 文件路径  撤销项目中文件修改的内容（针对该文件还未执行 git add 命令被添加过）\ngit reset HEAD 文件路径  取消添加文件，取消添加文件之后，可以通过 checkout 命令撤销修改\ngit log  查看提交记录\ngit log 提交记录id -1  查看特定一行的提交记录\ngit log 提交记录id -1 -p  查看特定的提交记录对应的所修改的内容\n\n网络\n\n查看连接的 wifi 密码\n\ncd/\nnetsh\nwlan show profile\nwlan show profile + 目标 wifi 名称 + key=clear\n\n\n\n","plink":"https://zhoufeichi.com/2018/06/14/Key/"},{"title":"Crash处理流程","date":"2018-04-11T06:23:39.000Z","date_formatted":{"ll":"Apr 11, 2018","L":"04/11/2018","MM-DD":"04-11"},"updated":"2022-01-25T02:59:30.293Z","content":"  我们通常使用try...catch语句来捕获异常，对于没有有效的catch exception，就会导致应用 crash ，当出现 exception 没有 catch 的情况，系统便会来进行捕获，并进入 crash 流程。在进程创建之初会设置未捕获异常的处理器，当系统抛出未捕获的异常时，最终都交给异常处理器。进程创建过程中，会调用RuntimeInit.java的commonInit()方法设置 KillApplicationHandler , 用于处理未捕获异常。\n  在RuntimeInit类中的commonInit()方法中，通过Thread.setDefaultUncaughtExceptionHandler(new KillApplicationHandler())将异常处理器 handler 对象赋给 Thread 成员变量,在 KillApplicationHandler 类中，复写了uncaughtException(...)方法，在uncaughtException(...)方法中，会根据进程类型，分别打印对应的 FATAL EXCEPTION 信息，接着会启动 crash 对话框ActivityManager.getService.handleApplicationCrash(mApplicationObject, new ApplicationErrorReport.ParcelableCrashInfo(e))，等待处理完成。AMP 经过 binder 调用最终交给 ActivityManagerService 中相应的方法去处理，故接下来调用的是AMS.handleApplicationCrash()。在 CrashInfo 对象中，会封装好 crash 信息文件名，类名，方法名，对应行号以及异常信息，同时会输出栈 trace 。\n  在 AMS 的handleApplicationCrash(...)中，首先需要获取进程 record 对象，根据获取到的对象来获取进程名，此时有几种情况：\n\n当远程IBinder对象为空时，则进程名为system_server\n当远程IBinder对象不为空，且ProcessRecord为空时，则进程名为unknown\n当远程IBinder对象不为空，且ProcessRecord不为空时，则进程名为ProcessRecord对象中相应进程名\n\n  获取到进程名之后，会进入到方法handleApplicationCrashInner(...)方法的执行过程当中。在这个方法中，会将 Crash 信息写入到 EventLog 中，将错误信息添加到 DropBox 中，将错误信息添加到 DropBox 其实是将 crash 信息输出到目录 /data/system/dropbox 。例如 system_server 的 dropbox 文件名为 system_server_crash@xxx.txt (xxx代表的是时间戳)。接下来就需要执行crashApplication(...)方法。\n   crashApplication(...)是 AppErrors 类中的方法，\n123AppErrors.crashApplication(...)    AppErrors.crashApplicationInner(...)        AppErrors.makeAppCrashingLocked(...)\n  调用了makeAppCrashingLocked(...)来继续处理 crash 流程，还需要做的事情就是发送消息 SHOW_ERROR_MSG ，弹出提示 crash 的对话框，等待用户选择。进入到makeAppCrashingLocked(...)方法的执行过程中，需要做的事情就是先把 crash 信息封装到 crashingReport 对象中。\n12345makeAppCrashingLocked(...)    app.crashingReport = generateProcessError(...)    startAppProblemLocked(app)    app.stopFreezingAllLocked()    return handleAppCrashLocked(...)\n  那么在startAppProblemLocked(app)方法中，\n123startAppProblemLocked(app)    app.errorReportReceiver = ApplicationErrorReport.getErrorReportReceiver(...)    skipCurrentReceiverLocked(app)\n  会获取当前用户下的 crash 应用的 error receiver，然后会忽略当前 app 的广播接收。在忽略当前 app 的广播接收过程中，其实是针对每个广播队列，都会执行对应队列的skipCurrentReceiverLocked(app)方法来结束 app 进程对应的广播的接收。\n  在startAppProblemLocked(app)执行完了之后，便会执行stopFreezingAllLocked()来执行停止屏幕冻结的操作。\n1234ProcessRecord.stopFreezingAllLocked()    activities.get(i).stopFreezingScreenLocked(force:true)  //ActivityRecord.stopFreezingScreenLocked    service.mWindowManager.stopFreezingScreen(appToken, force)  //WMS.stopFreezingScreen    WMS.stopFreezingDisplayLocked()\n  在WMS.stopFreezingDisplayLocked()方法中，做的事情包括:\n\n处理屏幕旋转相关逻辑\n移除冻屏的超时消息\n屏幕旋转动画的相关操作\n使能输入事件分发功能\ndisplay冻结时，执行gc操作\n更新当前的屏幕方向\n向 mH 发送 configuration 改变的消息\n\n  到此处stopFreezingAllLocked()方法执行结束，接下来就是需要执行handleAppCrashLocked(...)方法，在该方法中，主要的执行逻辑如下:\n\n当同一进程在时间间隔小于1分钟时连续两次 crash，则执行的情况如下：\n\n对于非persistent进程：\n\nmStackSupervisor.handleAppCrashLocked(app)\nremoveProcessLocked(app, false, false, “crash”)\nmStackSupervisor.resumeTopActivitiesLocked()\n\n\n对于persistent进程，则只执行\n\nmStackSupervisor.resumeTopActivitiesLocked()\n\n\n\n\n否则执行\n\nmStackSupervisor.finishTopRunningActivityLocked(app, reason)\n\n\n\n  在方法ActivityStackSupervisor.handleAppCrashLocked(app)中，\n12ASS.handleAppCrashLocked(app)ActivityStack.handleAppCrashLocked(app)\n  这个方法的目的就是用来结束当前 activity ，在方法体内，通过遍历 stack 中 task ，获取到 task 中的所有 activity ，遍历所有 activities ，找到位于该 ProcessRecord 的所有 ActivityRecord ，通过调用finishCurrentActivityLocked(...)方法来结束该 activity 。\n  下一步会执行AMS.removeProcessLocked(...)方法，在该方法中，首先会从 mProcessNames 中移除该进程，还需要通过app.kill()进行杀进程的操作，移除进程并清空该进程相关联的 activity/service 等组件。此处 mProcessNames 数据类型为 ProcessMap，这是以进程名为 key，记录着所有的ProcessRecord 信息。移除进程并清空该进程相关联的 activity/service 等组件是通过AMS.handleAppDiedLocked()来处理，主要包括清除应用中的 activity/service/receiver/ContentProvider 信息。\n  下一步就是执行ASS.resumeTopActivitiesLocked()，该方法执行完，就完成了 activity 的 resume 的过程。\n123ASS.resumeTopActivitiesLocked()    AS.resumeTopActivityLocked()        As.resumeTopActivityInnerLocked()\n  针对另一种情况，在执行ASS.finishTopRunningActivityLocked(...)方法的时候，\n123ASS.finishTopRunningActivityLocked(...)    stack.finishTopRunningActivityLocked(app, reason)    AS.finishActivityLocked(...)\n  在这个方法中，最终会回调到 activity 的 pause 方法。最后处理完makeAppCrashingLocked(...)方法，则会再发送消息 SHOW_ERROR_MSG ，弹出提示 crash 的对话框。处理 SHOW_ERROR_MSG 的消息则是 UiHandler 通过 handleMessage 来完成的。系统会弹出提示 crash 的对话框，并阻塞等待用户选择是“退出”或 “退出并报告”，当用户不做任何选择时 5min 超时后，默认选择“退出”，当手机休眠时也默认选择“退出”。到这里，最后在 uncaughtException 中在 finally 语句块还有一个杀进程的动作，通过 finally 语句块中执行Process.killProcess(...)来保证彻底杀掉 crash 进程。\n  最后还有一个 Binder 的死亡回调过程，在应用进程创建的过程中有一个attachApplicationLocked()方法的过程中便会创建死亡通知。当 binder 服务端挂了之后，便会通过 binder 的 DeathRecipient 来通知 AMS 进行相应的清理收尾工作。前面讲到 crash 的进程会被 kill 掉，那么当该进程被杀，则会回调到binderDied()方法。\n12345AMS.binderDied()    AMS.appDiedLocked()        AMS.handleAppDiedLocked(...)            AMS.cleanUpApplicationRecordLocked(...)  //清理应用程序service, BroadcastReceiver, ContentProvider相关信息                app.activities.clear()  //清理 activity 相关信息\n  清理 ContentProvider 的过程，首先获取该进程已发表的 ContentProvider ，将 DyingProvider 清理掉，这包括 ContentProvider 的服务端和客户端都会被杀。还需要处理的就是正在启动并且有客户端正在等待的 ContentProvider 。最后就是取消已连接的 ContentProvider 的注册。清理 BroadcastReceiver 主要就是取消注册的广播接收者。\n  当 crash 进程执行 kill 操作后，进程被杀。由于 crash 进程中拥有一个 Binder 服务端 ApplicationThread ，而应用进程在创建过程调用attachApplicationLocked()，从而 attach 到 system_server 进程，在 system_server 进程内有一个 ApplicationThreadProxy ，这是相对应的 Binder 客户端。当 Binder 服务端 ApplicationThread 所在进程(即 crash 进程)挂掉后，则 Binder 客户端能收到相应的死亡通知，从而进入 binderDied 流程。\n","plink":"https://zhoufeichi.com/2018/04/11/Crash处理流程/"},{"title":"亮灭屏流程","date":"2018-04-03T03:39:08.000Z","date_formatted":{"ll":"Apr 3, 2018","L":"04/03/2018","MM-DD":"04-03"},"updated":"2020-04-04T05:59:18.673Z","content":"  用户按了 power 键之后，首先涉及到的是 Input 的流程，按键事件最终会从 InputManagerService 传到 PhoneWindowManager 处理，最终这个按键事件是传递到 PhoneWindowManager 的interceptKeyBeforeQueue() 方法中。\n","plink":"https://zhoufeichi.com/2018/04/03/亮灭屏流程/"},{"title":"Input系统ANR总结","date":"2018-03-30T07:46:44.000Z","date_formatted":{"ll":"Mar 30, 2018","L":"03/30/2018","MM-DD":"03-30"},"updated":"2020-06-13T09:04:57.947Z","content":"   InputReader 的工作主要是:\n\n\n调用 EventHub 的getEvents()读取节点 /dev/input 的 input_event 结构体，转换成 RawEvent 结构体， RawEvent 根据不同 InputMapper 来转换相应的 EventEntry，比如按键事件，那么对应的是 KeyEntry ，触摸事件则对应的是 MotionEntry 。那么这个过程就是将 input_event 转换成 EventEntry 。\n\n\n将事件添加到 mInboundQueue 队列尾部，加入该队列前首先会执行IMS.interceptKeyBeforeQueueing(...)方法，在这个方法里可以增加业务逻辑，然后会执行IMS.filterInputEvent(...)方法，这个方法用来处理可拦截事件，当该方法的返回值为 false 的时候，会直接拦截，这种情况下，该事件没有机会加入到 mInboundQueue 队列，不会再继续往下分发，如果事件没有被拦截到，那么该事件将会被加入到 mInboundQueue 队列尾部，事件加入到 mInboundQueue 队列之后，会通过mLooper-&gt;wake来唤醒 InputDispatcher 线程。\n\n\n在InputReader 的工作过程中，还会调用KeyboardInputMapper.processKey()来记录按下 down 事件的时间点。\n\n\n   InputDispatcher 的工作主要是:\n\n\n通过调用dispatchOnceInnerLocked()从 InputDispatcher 的 mInboundQueue 队列中取出事件 EventEntry 。该方法开始执行的时间点是后续操作 dispatchEntry 的分发事件。获取到 EventEntry 事件之后，会生成事件 DispatchEntry 并加入 connection 的 outbound 队列 。startDispatchCycleLocked()负责从 outboundQueue 队列中取出事件 DispatchEntry ，并放入 connection 的 waitQueue 队列中。\n\n\n通过runCommandsLockedInterruptible()方法循环遍历的方式，依次处理 mCommandQueue 队列中的所有命令。而 mCommandQueue 队列中的命令是通过postCommandLocked()方式向该队列添加的，ANR 回调命令便是在这个时机执行。\n\n\nhandleTargetsNotReadyLocked()方法会判断是否等待超过 5s 来决定是否调用onANRLocked()。\n\n\n","plink":"https://zhoufeichi.com/2018/03/30/Input系统ANR总结/"},{"title":"Input系统之InputDisptcher线程","date":"2018-03-30T05:17:43.000Z","date_formatted":{"ll":"Mar 30, 2018","L":"03/30/2018","MM-DD":"03-30"},"updated":"2020-04-04T05:59:18.673Z","content":"   InputReader 利用 EventHub 获取数据后生成 EventEntry 事件，加入到 InputDispatcher 的 mInboundQueue 队列，再唤醒 InputDispatcher 线程。InputDispatcher，同样从 threadLoop 为起点开始。threadLoop()中执行完dispatchOnce()之后会返回 Bool 类型的值。线程 Thread 类中有一个虚函数 threadLoop()，对于 Thread 的派生类 InputDispatcherThread 就实现了threadLoop()方法。事件的读取和派送过程是一直循环的，这就需要threadLoop()不断循环的执行。在 Thread 的run()方法中会实现创建线程的过程，在 Thread 类的run()方法执行后，会调用底层库 libpthread 的方法pthread_create()创建线程，并执行回调方法_threadLoop()。_threadLoop()便控制着threadLoop()的循环，这是在_threadLoop()方法中，有一个do while循环，每次执行完threadLoop()之后会记录threadLoop()的返回值，如果返回值不是 false ，那么便会一直循环执行threadLoop()。\n   InputDispatcher 对象在初始化的过程中，需要创建自己的 Looper 对象，然后获取分发超时参数，超时参数来自于 IMS ，参数默认值 keyRepeatTimeout = 500 ，keyRepeatDelay = 50。事件的分发是通过不断循环地调用 InputDispatcher 的dispatchOnce()来分发事件。在dispatchOnce()方法中，\n123456789dispatchOnce()\tdispatchOnceInnerLocked(...)\t\tmInboundQueue.dequeueAtHead()\t\tresetANRTimeoutsLocked()\t\tdispatchKeyLocked(...)\t\tdropInboundEventLocked(...)\t\treleasePendingEventLocked()\trunCommandsLockedInterruptible()\tmLooper-&gt;pollOnce(timeoutMillis)\n  在dispathOnceInnerLocked(...)方法中，首先判断是否需要冻结事件分发工作不再执行，如果事件分发正常进行，判断事件分发的事件点距离该事件加入 mInboundQueue 的时间是否超过 500ms，超过500ms，则认为 app 切换过期，接下来就需要判断在 mInboundQueue 中是否有事件需要处理，如果没有需要处理的事件，那么会直接 return 返回。如果存在需要处理的事件，那么需要从 mInboundQueue 中取出头部的事件mInboundQueue.dequeueAtHead()，接着调用resetANRTimeoutsLocked()重置 ANR 信息。获取到需要处理的事件 mPendingEvent 之后，判断待处理事件的类型，根据不同的类型会相应的执行分发事件的操作，比如对于按键事件的分发则是通过dispatchKeyLocked(...)来实现的，分发动作完成之后会进行任务完成之后 done 的操作，首先需要判断是否需要丢弃事件，对于需要丢弃的事件，那么需要调用dropInboundEventLocked(...)来处理，最后还需要调用releasePendingEventLocked()释放当前正在处理的事件 mPendingEvent。在 dispatchKeyLocked 的分发事件执行完之后，\n\n不会执行 done 的情况:\n\n当前 Event 时间小于唤醒时间\n让 policy 有机会执行拦截操作\n调用 findFocusedWindowTargetsLocked 方法的返回结果是 INPUT_EVENT_INJECTION_PENDING, 即 targets 没有处于 Ready 状态\n\n\n会执行 done 的情况:\n\n该事件需要丢弃，即 dropReason != DROP_REASON_NOT_DROPPED\nfindFocusedWindowTargetsLocked 的返回结果不是 INPUT_EVENT_INJECTION_PENDING(没有正在处理的事件)\n\n\n\n  在dispatchKeyLocked()方法中，会根据事件的 interceptKeyResult 的类型来进行不同的处理，如果 interceptKeyResult 的类型为KeyEntry::INTERCEPT_KEY_RESULT_TRY_AGAIN_LATER那么会进行唤醒时间的判断，如果当前时间小于唤醒时间，那么会进入等待状态，同时返回 false 。如果 interceptKetResult 的类型为KeyEntry::INTERCEPT_KEY_RESULT_UNKNOWN，那么就会让 policy 有机会执行拦截操作，同时也会返回 false 。如果需要丢弃该事件，需要执行清理操作，直接返回 true 。然后需要做的就是调用方法findFocusedWindowTargetsLocked(...)寻找焦点。如果寻找焦点失败，那么直接返回 false 。只有寻找焦点的结果 injectionResult 是成功的，那么才有机会真正的分发事件dispatchEventLocked(...)，因此可知，下列场景可能导致无法分发事件。\n\n当前时间小于唤醒时间\npolicy 提前拦截事件\n需要 drop 事件的情况\n寻找聚焦窗口失败\n\n  如果不出现上述的这些情况，那么会正常进入事件分发的过程，在事件分发完成之后，也会正常进入前面提到的 Done 的处理过程，\n","plink":"https://zhoufeichi.com/2018/03/30/Input系统之InputDisptcher线程/"},{"title":"Input系统之InputReader线程","date":"2018-03-30T02:01:33.000Z","date_formatted":{"ll":"Mar 30, 2018","L":"03/30/2018","MM-DD":"03-30"},"updated":"2020-04-04T05:59:18.673Z","content":"获取事件\n   InputReader 线程的执行过程从 threadLoop 开始，在threadLoop()中，会调用loopOnce()方法，同时会返回 true 。返回值 true 代表会不断的循环调用loopOnce()方法。进入到 loopOnce() 方法中，需要通过mEventHub-&gt;getEvents从 EventHub 中获取事件，在 EventHub 类的 getEvents 方法中，会有如下的操作过程，\n12345getEvents(...)\tscanDevicesLocked()\t\tscanDirLocked(DEVICE_PATH)\t\t\topenDeviceLocked(devname)\t\t\t\taddDeviceLocked(device)\n  那么从进入到getEvents(...)方法体中开始，如果需要扫描设备，那么则先会通过调用scanDevicesLocked()来扫描 DEVICE_PATH 为/dev/input的所有设备，在scanDevicesLocked()方法体内会进一步调用scanDirLocked(DEVICE_PATH)方法，在scanDirLocked(...)中，根据传进来的 DEVICE_PATH 路径，接下来要做的就是读取/dev/input/目录下所有的设备节点。读取到设备节点之后通过调用openDeviceLocked(...)方法来打开相应的设备节点，在openDeviceLocked(...)方法中需要处理以下事件:\n\n打开设备文件 fd = open(devicePath, ...)\n获取设备名\n获取设备物理地址\n获取设备唯一ID uniqueId\n将获取到的设备名、设备物理地址、唯一 ID 等这些 identifier 信息填充到刚开始打开的设备文件中\n设置 fd 为非阻塞方式\n获取设备Id(deviceId)，为设备对象分配内存空间device = new Device(...)\n注册 epoll\n调用 addDeviceLocked(device)，该方法的作用就是将 device 添加到 mDevices 队列，同时将 device 对象赋值给 mOpeningDevies。\n\n处理事件\n  前面便是 EventHub 已经完成了从设备节点获取事件并将事件封装成 RawEvent 的过程，获取事件之后会通过调用InputReader::processEventsLocked(...)方法来处理事件，也会根据事件的类型来进行一些设备增删等操作，\n\nDEVICE_ADDED: 设备增加\n\n123addDeviceLocked(...)\tcreateDeviceLocked(...)\tmDevices.add(deviceId, device)\n  在createDeviceLocked(...)方法的作用就是创建并获得一个 InputDevice 对象，那么在这个方法中首先就是创建了一个 InputDevice 对象，将 InputReader 的 mContext 赋值给 InputDevice 对象所对应的变量。然后需要根据设备类型来创建并添加相应的 InputMapper ，同时设置 mContext 。 input 设备类型有常见的以下几种：\n\n键盘类设备：KeyboardInputMapper\t\t\n触摸屏设备：MultiTouchInputMapper 或 SingleTouchInputMapper\t\t\n鼠标类设备：CursorInputMapper\n\n\nDEVICE_REMOVED: 设备移除\nFINISHED_DEVICE_SCAN: 设备扫描完成\n\n  除了设备的增删这些事件的操作，事件的处理是通过processEventsForDeviceLocked(...)方法来实现，\n123processEventsForDeviceLocked(...)\tdevice-&gt;process(...)\t\tmapper-&gt;process(rawEvent)\n  在processEventsForDeviceLocked(...)方法中，需要先获得 InputDevice 对象 device ，然后通过调用device-&gt;process(...)来进一步处理。最终也是根据不同的 InputMapper 种类来处理不同的按键事件。比如对于键盘类设备，调用的是 KeyboardInputMapper 类中的process()方法。\n12345mapper-&gt;processs(...)\tgetEventHub()-&gt;mapKey(...)\t\tKeyCharacterMap-&gt;mapKey(...)\tInputMapper.processKey(...)\t\t getListener()-&gt;notifyKey(...)\n  在process()方法中，首先就是需要获取 keyCode ，然后再是processKey(...)的过程。在这个过程中，判断是键盘是按下还是抬起，并获取相应的 keyCode 事件，根据获取到的 keyCode 等信息最终需要通知 key 事件，此处 KeyboardInputMapper 的 mContext 指向 InputReader，还需要做的事情就是将这些按键事件封装到 NotifyKeyArgs 对象 args 中，getListener()获取的便是 mQueuedListener 。 接下来调用该对象的 QueuedInputListener::notifyKey(...)方法，在这个notifyKey(...)方法中，会将该 key 事件压入类型为 Vector&lt;NotifyArgs*&gt;栈顶，接下来要做的就是将事件发送给 InputDispatcher 线程。\n发送事件\n  processEventsLocked()是对事件进行加工的过程，将 RawEvent 转换成NotifyKeyArgs(NotifyArgs)。执行完processEventsLocked()后，需要通过mQueuedListener-&gt;flush()来实现将事件发送给 InputDispatcher 线程。\n123456789flush()\targs-&gt;notify(mInnerListener)\t\tmInnerListener-&gt;notifyKey(this)  // this是指NotifyKeyArgs\t\t\tevent.initialize(...)\t//初始化 KeyEvent 对象\t\t\tmPolicy-&gt;interceptKeyBeforeQueueing(...)\t\t\tmPolicy-&gt;filterInputEvent(...)\t\t\tnew KeyEntry(...)\t//创建 KeyEntry 对象\t\t\tenqueueInboundEventLocked(newEntry)\t\t\tmLooper-&gt;wake()\t //唤醒 InputDispatcher 线程\n  我们知道前面处理的是 KeyCode 相关的事件，因此此处的 args 是 NotifyKeyArgs 对象， mInnerListener 是 InputDispatcher 类型， mPolicy 是指 NativeInputManager 对象。调用NativeInputManager.interceptKeyBeforeQueueing(...)方法在加入队列前执行拦截动作时会调用 Java 层的InputManagerService.interceptKeyBeforeQueueing()方法。当 mInputFilterEnabled = true(该值默认为false,可通过 setInputFilterEnabled 设置),则调用NativeInputManager.filterInputEvent(...)过滤输入事件。\n  在enqueueInboundEventLocked(newEntry)方法中，EventEntry 类型为 TYPE_MOTION ，那么需要执行findTouchedWindowAtLocked(...)来查找可触摸窗口。最后执行完如果满足下列条件，那么则需要唤醒 InputDispatcher 线程。\n\n执行enqueueInboundEventLocked(...)方法前， mInboundQueue 队列为空,执行完必然不再为空,则需要唤醒分发线程\n当事件类型为 key 事件，且发生一对按下和抬起操作,则需要唤醒\n当事件类型为 motion 事件，且当前可触摸的窗口属于另一个应用，则需要唤醒\n\n  那么QueuedListener_flush()的过程就是将事件发送到 InputDispatcher 线程，转换 NotifyKeyArgs 为 KeyEntry。\n   InputReader 线程不断循环的执行InputReader.loopOnce()，每次从 EventHub 获取数据后生成 EventEntry ，最后再交给 InputDispatcher 线程处理。\n","plink":"https://zhoufeichi.com/2018/03/30/Input系统之InputReader线程/"},{"title":"Input系统之UI线程","date":"2018-03-20T06:05:36.000Z","date_formatted":{"ll":"Mar 20, 2018","L":"03/20/2018","MM-DD":"03-20"},"updated":"2020-04-04T05:59:18.673Z","content":"   InputReader 和 InputDispatcher 运行在 system_server 进程，用户点击的界面往往可能是某个 app 。而每个 app 运行在自己的进程，这就涉及到跨进程之间的通信，也就是 app 进行和 system 进程建立通信。\n   Activity 会对应一个应用窗口，每个应用窗口对应一个 ViewRootImpl 。在 Activity 启动时，会调用到Activity.onCreate(...)方法，在onCreate(...)方法中，会再调用setContentView(...)，这涉及到 AMS 和 WMS 的各种交互，再往下走最终会调用WindowManagerGlobal.addView(...)方法。在addView(...)方法中，\n123addView(...)\tViewRootImpl root = new ViewRootImpl(...)\troot.setView(...)\n  在 创建 ViewRootImpl 的对象时，首先会通过WindowManagerGlobal.getWindowSession()获取 IWindowSession 的代理类，\n12345678getWindowSession()\t//获取 IMS 的代理类\tInputMethodManager imm = InputMethodManager.getInstance()\t//获取WMS的代理类\tIWindowManager windowManager = getWindowManagerService()\t//经过Binder调用，最终调用WMS\tsWindowSession = windowManager.openSession(..., imm.getClient(), imm.getInputContext())\treturn sWindowSession\n  在这个过程中， Session 对象创建好了之后，会通过 Binder 将数据写回 app 进程，那么 app 进程便获得了 Session 的代理对象。接下类就是setView(...)的过程，\n1234setView(...)\tmInputChannel = new InputChannel(); //创建InputChannel对象\tres = mWindowSession.addToDisplay(...)\tmInputEventReceiver = new WindowInputEventReceiver(...)\n  创建好的 mInputChannel 对象会作为参数传入mWindowSession.addToDislplay(...)方法中，这也是通过 Binder 的通信方式，最终调用的是mService.addWindow(...)方法，在WMS.addWindow(...)方法中，\n12345678910111213WindowState win = new WindowState(...)//根据WindowState的HashCode以及title来生成InputChannel名称String name = win.makeInputChannelName()//创建一对InputChannelInputChannel[] inputChannels = InputChannel.openInputChannelPair(name)//将socket服务端保存到WindowState的mInputChannelwin.setInputChannel(inputChannels[0])\t\t\t\t        //socket客户端传递给outInputChannelinputChannels[1].transferTo(outInputChannel)//利用socket服务端作为参数mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle)//设置当前聚焦窗口\tmInputMonitor.updateInputWindowsLw(false /*force*/)\n  在创建 InputChannels 数组的过程中，首先是创建两个 socket 对象，创建两个 InputChannel 对象，socket 对象会分别和两个 InputChannel 对象绑定，创建两个 NativeInputChannel 对象之后，nativeInputChannel 对象会跟 InputChannel 对象绑定在一起，即将 nativeInputChannel 保存到 java 层的 InputChannel 的成员变量 mPtr 。最后需要做的事情就是将 client 和 server 插入到 channelPair 中，得到的 channelPair 会返回给 inputChannels 数组。\n  得到 inputChannels 数组之后，inputChannels[0] 对应的是服务端，而 inputChannels[1] 对应的是客户端，在这里将服务端\n保存在 WindowState 的 mInputChannel 中，客户端传送给 outInputChannel 对象，而这个 outInputChannel 正是作为参数传递过来的 App 进程中 ViewRootImpl 的 mInputChannel。\n","plink":"https://zhoufeichi.com/2018/03/20/Input系统之UI线程/"},{"title":"Input 系统启动","date":"2018-03-14T02:22:46.000Z","date_formatted":{"ll":"Mar 14, 2018","L":"03/14/2018","MM-DD":"03-14"},"updated":"2020-04-04T05:59:18.673Z","content":"介绍\n  当用户触摸屏幕或者按键操作，首次触发硬件驱动，驱动收到事件后，将该相应事件写入到输入设备节点，接着，输入系统取出原生态的事件，经过层层封装后成为 KeyEvent 或者 MotionEvent 。最后，交付给相应的目标窗口(Window)来消费该输入事件。可见，输入系统在整个过程起到承上启下的衔接作用。\n   Input 模块的作用如下:\n\nNative 层的 InputReader 负责从 EventHub 取出事件并处理，再交给 InputDispatcher\nNative 层的 InputDispatcher 接收来自 InputReader 的输入事件，并记录 WMS 的窗口信息，用于派发事件到合适的窗口\nJava 层的 InputManagerService 跟 WMS 交互，WMS 记录所有窗口信息，并同步更新到 IMS ，为 InputDispatcher 正确派发事件到 ViewRootImpl 提供保障\nNative 层的 InputReader 对象中含有一个类型为 QueueInputListener 的对象 mQueuedListener 。mQueuedListener 的内部类 mInnerListener 是和 InputDispatcher 通信的纽带。\n\n启动过程\n   IMS 服务是随着 system_server 进程的启动而启动的,所调用的方法的逻辑关系如下:\nnew InputManagerService(context)\n\tnativeInit(...)\n\t\tnew NativeInputManager(...)\n\t\t\tnew EventHub\n\t\t\tnew InputManager(...)\n\t\t\t\tnew InputDispatcher(...)\n\t\t\t\t\tnew Looper(false)\n\t\t\t\tInputReader(...)\n\t\t\t\t\tnew QueuedInputListener(...)\n\t\t\t\tinitialize()\n\t\t\t\t\tnew InputReaderThread(...)\n\t\t\t\t\tnew InputDispatcherThread(...)\nIMS.start()\n    nativeStart(mPtr)\n\t\tInputManager-&gt;start()\n\t\t\tInputReaderThread-&gt;run()\n\t\t\tInputDispatcherThread-&gt;run()\n\n  InputManagerService 的初始化过程是通过new InputManagerService(context)，在 new 的过程中，首先有一个初始化 native 对象的过程，在这个过程中，首先会获取 native 消息队列，最后还需要创建 native 的 InputManager 对象。通过new NativeInputManager(...)\n创建 NativeInputManager 对象时，其实是根据上层 IMS 的 context 以及上层 IMS 对象来进行一些变量的赋值，同时在构造 NativeInputManager 对象时，还需要创建 EventHub 对象和 InputManager 对象。\n  在创建 EventHub 对象时，首先会创建 epoll 实例，并会初始化 INotify 来监听 /dev/input，并会将 INotify 添加到 epoll 实例。然后做的就是创建非阻塞模式的管道，并添加到 epoll 。\n  在 InputManager 类的构造函数中，会创建 InputDispatcher 对象和 InputReader 对象。\n  在 InputDispatcher 的构造函数中，会创建属于自己线程的 Looper 对象，接着获取分发超时参数，超时参数来自 IMS ，参数默认值 keyRepeatTimeout = 500， keyRepeatDelay = 50。\n  在创建 InputReader 对象的时候会传入一个已经创建好的 eventHub 对象，InputReader 的作用就是用来读取 EventHub 中的事件，从而传递给 InputDispatcher 的，在这里将 EventHub 对象传递到 InputReader 的有参构造方法中，以便 InputReader 能够取出 EventHub 中的事件。同时在 InputReader  的构造方法中，会创建输入监听对象new QueuedInputListener(listener)，这便是 InputReader 和 InputDispatcher 联系的纽带，通过 QueuedInputListener 内部成员变量 mInnerListener 指向 InputDispatcher 对象。这里的 listener 便是 InputDispatcher 对象。\n  创建好 InputReader 和 InputDispatcher 对象之后，接着就是执行 initialize 的过程，初始化的主要工作就是创建两个(InputReaderThread 和 InputDispatcherThread)能访问 Java 代码的 native 线程。到此处便是 InputManagerService 完成了对象的创建和初始化的过程，接下来便是调用其 start 方法。\n  在IMS.start()方法中，首先会通过nativeStart(mPtr)启动 native 对象，此处 ptr 记录的是 NativeInputManager 对象，通过 ptr 获取到 NativeInputManager 对象 im 后，通过im-&gt;getInputManager()-&gt;start()来启动，在InputManager.start()方法中，主要做的就是启动 InputReaderThread 和 InputDispatcherThread 两个线程。启动好 native 对象之后，接着使用registerPointerSpeedSettingObserver()注册触摸点速度的观察者，使用registerShowTouchesSettingObserver()注册是否显示功能的观察者，然后再注册广播，通过接受广播来更新触摸点速度以及确定是否在屏幕上显示触摸点。\n","plink":"https://zhoufeichi.com/2018/03/14/Input系统之启动过程/"},{"title":"Git使用总结","date":"2018-03-11T10:23:39.000Z","date_formatted":{"ll":"Mar 11, 2018","L":"03/11/2018","MM-DD":"03-11"},"updated":"2022-01-24T11:02:36.647Z","content":"创建仓库\n\n\n进入一个目录\ncd dir\n\n\n为仓库新建一个空的目录\nmkdir myrepository\n\n\n进入该新的目录\ncd myrepository\n\n\n初始化目录，使其成为一个空的仓库\ngit init\n\n\n往仓库添加内容\n\n\n使用add命令往仓库添加内容\ngit add &quot;file_name&quot;\n\n\n提交内容\ngit commit -m &quot;notes&quot;\n参数说明：\n\n-m: &quot;notes&quot;描述此次修改的说明，如果不加 -m 参数，那么会进去vi编辑模式，让你添加内容\n\nvi模式中,\n\n命令 i 表示插入\nshift + :表示进入命令行，可以输入指令\nwq表示强制性写入文件并退出，即使文件没有被修改也强制写入，并更新文件的修改时间\nx表示写入文件并退出，仅当文件被修改时才写入，并更新文件修改时间，否则不会更新文件修改时间\n\n\n当 commit 的时候发现 message 信息写错时\n\n还未 push 的情况下，通过`git commit --amend -m &quot;message&quot;来修改注释信息\n已经 push ，但是远程没有其他人下载或者改动\n\ngit commit --amend -m &quot;message&quot;修改信息\ngit push --force-with-lease origin master推送到远程\n\n\n已经 push ，而且已经有其他人下载或改动\n\ngit fetch origin\ngit reset --hard origin/master\n\n\n\n\n\n\n\n\n\n可以使用git status来查看当前的仓库状态，包括是否发生更改，但是还未提交。当我们知道有内容更改后可以继续用git diff命令来查看修改的东西\n\n\n版本回退\n\n\n使用命令git reset --hard HEAD^来回到上一个版本\n\nHEAD^表示上一个版本\nHEAD^^表示回退两个版本，以此类推\nHEAD~100表示回退100个版本\n\n\n\n使用git reflog来查看你的历史操作\n\n\n只在工作区修改，使用git checkout -- &quot;file_name&quot;来撤销工作区的修改\n\n\n已经 add 到暂存区了，使用git reset HEAD &quot;file_name&quot;来撤销暂存区的修改（它是将版本库中的文件恢复到暂存区中），然后再用git checkout -- &quot;file_name&quot;来撤销工作区的修改（它是将暂存区中的文件恢复到工作区中）\n\n\n创建分支\n\n\n创建分支可以用 git checkout -b dev，相当于两个语句：\n\ngit branch dev: 创建分支\ngit checkout dev: 切换到分支\n\n\n\ngit branch 列出所有分支，当前分支前面有个 *\n\n\ngit checkout -- &quot;file_name&quot;用于恢复文件，从暂存区恢复文件到工作区\n\n\ngit checkout dev用于切换分支\n\n\ngit merge dev合并分支，这种方式是 fast forward 方式，也就是直接把 master 指向 dev 的当前提交，所以合并速度非常快\n\n\ngit merge --no-ff -m &quot;master: merger dev with no-ff&quot; dev，这种方式是因为本次合并要创建一个新的 commit ，所以加上 -m 参数，把 commit 描述写进去，这种方式 master 指向自己的提交\n\n\ngit branch -d dev用于删除分支\n\n\ngit log --graph用于查看分支合并图\n\n\n当前任务没完成时，如果需要完成其他任务，可以使用命令git stash先保存当前工作现场，完成其他任务后，切换到原来的分支，然后可以使用命令git stash list来查看保存有哪些工作现场，找到目的工作现场，然后使用git stash pop命令来恢复现场，同时也可以使用git stash apply stash@&#123;0&#125;来恢复stash@&#123;0&#125;的工作现场\n\ngit stash apply: 恢复工作现场后，stash 内容不删除，要使用git stash drop来删除\ngit stash pop恢复工作现场后，stash 内容直接删除了\n\n\n\n远程仓库\n\n\n进入你想要和远程仓库关联的本地仓库目录下，使用git remote add origin &quot;远程仓库地址&quot;，添加后 origin 就是远程仓库的地址\n\n\n使用git push -u origin master，将当前分支 master 推送到远程仓库上，由于远程库是空的，我们第一次推送 master 分支时，加上了 -u 参数，git 不但会把本地的 master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来，在以后的推送或者拉取时就可以简化命令。以后可以直接使用命令git push origin master\n\n\ngit 支持多种协议，包括https，但通过 ssh 支持的原生 git 协议速度最快\n\n\n使用命令将git clone &quot;远程仓库地址&quot;克隆到本地\n\n\n","plink":"https://zhoufeichi.com/2018/03/11/Git/"},{"title":"ANR-ContentProvider","date":"2018-02-24T06:09:58.000Z","date_formatted":{"ll":"Feb 24, 2018","L":"02/24/2018","MM-DD":"02-24"},"updated":"2020-04-04T05:59:18.673Z","content":"   当 ActivityManager 线程中的 AMS.MainHandler 收到 CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG 消息时会触发 ContentProvider Timeout 事件。ContentProvider 超时与 Provider 进程启动过程相关， CONTENT_PROVIDER_PUBLISH_TIMEOUT = 10s。\n埋炸弹\n  在 Provider 启动的过程中，埋炸弹会发生在进程创建的阶段，进程创建后会调用AMS.attachApplicationLocked()进入 system_server 进程。在AMS.attachApplicationLocked()方法中，app 进程存在正在启动中的 provider ,则超时10s后发送 CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG 消息。\n12345if (providers != null &amp;&amp; checkAppInLaunchingProvidersLocked(app)) &#123;    Message msg = mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);    msg.obj = app;    mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT);&#125;\n拆炸弹\n  当 provider 通过AMS.publishContentProviders(...)成功 publish 之后,便会通过mHandler.removeMessages(...)拆除该炸弹。\n引爆炸弹\n  在前面埋炸弹的过程，会通过mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT)来发送一个超时消息，那么在倒计时结束后便会向 system_server 进程中名为 ActivityManager 的 handler 线程发送 CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG 消息。该线程通过handleMessage(...)的方式，来处理超时消息。\n12345handleMessage(...)    AMS.processContentProviderPublishTimedOutLocked(...)        AMS.cleanupAppInLaunchingProvidersLocked(...)            AMS.removeDyingProviderLocked(...)        AMS.removeProcessLocked(...)\n  removeDyingProviderLocked()方法的作用是移除死亡的 provider，在处理的过程中跟 provider 的类型有关：\n\n对于 stable 类型的 provider (即conn.stableCount &gt; 0),则会杀掉所有跟该 provider 建立 stable 连接的非 persistent 进程\n对于 unstable 类型的 provider (即conn.unstableCount &gt; 0),并不会导致 client 进程被级联所杀\n\n  对于 Service, Broadcast 发生 ANR 之后,最终都会调用 AMS.appNotResponding 。对于 provider ,在其进程启动时 publish 过程可能会出现 ANR, 则会直接杀进程以及清理相应信息,而不会弹出 ANR 的对话框。\n","plink":"https://zhoufeichi.com/2018/02/24/ANR-ContentProvider/"},{"title":"ANR-Broadcast","date":"2018-02-24T02:23:33.000Z","date_formatted":{"ll":"Feb 24, 2018","L":"02/24/2018","MM-DD":"02-24"},"updated":"2020-04-04T05:59:18.673Z","content":"   串行广播需要考虑超时的情况，接收者是串行处理的，前一个 receiver 处理慢，会影响后一个 receiver 。对于并行广播则是通过一个循环一次性向所有的receiver分发广播事件，所以不存在彼此影响的问题，则没有广播超时。\n串行广播通常有两种超时情况：\n\n某个广播总处理时间 &gt; 2 * receiver 总个数 * mTimeoutPeriod\n某个 receiver 的执行时间超过 mTimeoutPeriod\n\n   BroadcastQueue.BroadcastHandler 收到 BROADCAST_TIMEOUT_MSG 消息时会触发 ANR 事件。广播队列有两种：\n\nforeground 队列：对于前台广播，超时设置为 BROADCAST_FG_TIMEOUT = 10s\nbackground 队列：对于后台广播，超时设置为 BROADCAST_BG_TIMEOUT = 60s\n\n埋炸弹\n  processNextBroadcast 来处理广播时，首先处理并行广播,再处理当前有序广播,最后获取并处理下条有序广播。在这个过程中，在处理有序广播时，首先会获取该广播的所有接受者，然后就需要判断此时该广播的总时间是否超时，如果超时那么需要结束这条广播。如果没有超时，那么往下走就是进入处理广播消息的过程，处理完广播消息，系统需要获取下条有序广播，那么在获取下条有序广播的时候就有一个埋炸弹的过程，埋炸弹就是通过setBroadcastTimeoutLocked(timeoutTime)给该广播设置一个时间戳，以便后面来处理广播消息时判断是否已经超时。这需要在setBroadcastTimeoutLocked(...)方法中设置定时广播 BROADCAST_TIMEOUT_MSG，即当前往后推 mTimeoutPeriod 时间广播还没处理完毕，则进入广播超时流程。\n拆炸弹\n  正如前面说的在 processNextBroadcast 方法内，广播如果没有超时，那么会调用方法performReceiveLocked(...)来处理广播，执行完该方法之后，就会进行拆除炸弹的操作。拆除炸弹是通过cancelBroadcastTimeoutLocked()来移除广播超时消息 BROADCAST_TIMEOUT_MSG 。\n引爆炸弹\n   引爆炸弹的过程发生在 broadcastTimeoutLocked()方法中，首先判断是否有下列几种情况：\n\nmOrderedBroadcasts 已处理完成，则不会发生 anr\n正在执行 dexopt，则不会 anr\n系统还没有进入 ready 状态(mProcessesReady=false)，则不会anr\n如果当前正在执行的 receiver 没有超时，则重新设置广播超时，不会 anr\n\n  如果不是上面的几种情况，那么会通过mHandler.post(new AppNotResponding(app, anrMessage))发送 AppNotResponding 的消息，此时会进入 ANR 处理流程。\n1234567private final class AppNotResponding implements Runnable &#123;    ...    public void run() &#123;        // 进入ANR处理流程        mService.appNotResponding(mApp, null, null, false, mAnnotation);    &#125;&#125;\n","plink":"https://zhoufeichi.com/2018/02/24/ANR-Broadcast/"},{"title":"ANR-Service","date":"2018-02-13T03:13:35.000Z","date_formatted":{"ll":"Feb 13, 2018","L":"02/13/2018","MM-DD":"02-13"},"updated":"2020-04-04T05:59:18.673Z","content":"Service Timeout有两类:\n\n对于前台服务，则超时为SERVICE_TIMEOUT = 20s\n对于后台服务，则超时为SERVICE_BACKGROUND_TIMET = 200s\n\n埋炸弹\n  与 Service 相关的 ANR，埋炸弹阶段出现在realStartServiceLocked()方法中。\n1234realStartServiceLocked    bumpServiceExecutingLocked        scheduleServiceTimeoutLocked\n  在realStartServiceLocked方法中先是通过bumpServiceExecutingLocked发送一个delay消息(SERVICE_TIMEOUT_MSG)。而在bumpServiceExecutingLocked中是通过调用scheduleServiceTimeoutLocked来实现的。\n在scheduleServiceTimeoutLocked方法中，如果超时后依旧没有 remove 掉该 SERVICE_TIME_OUT 消息，那么会进入到service timeout流程。此时炸弹已经埋下，如果不希望炸弹被引爆，那么就需要在炸弹爆炸之前拆除炸弹。\n拆炸弹\n  拆炸弹的过程发生在目标进程的主线程调用handleCreateService的过程中。\n123handleCreateService    serviceDoneExecuting        removeMessages\n  在handleCreateService方法的处理过程中，会创建目标服务对象，以及回调onCreate方法，最后会执行ActivityManagerNative.getDefault().serviceDoneExecuting，这个过程是经过多次调用最后回到system server进程来执行 serviceDoneExecuting 以达到移除服务启动超时消息的目的。\n引爆炸弹\n  如果没有在指定时间之内拆掉炸弹，那么炸弹爆炸后会导致ANR。当计时结束之后，system server 进程中名为ActivityManager 的 Handler 线程会收到 SERVICE_TIMEOUT_MSG 的消息，ActivityManager 通过 handler 的通信方式，将该 MSG 发送给 MainHandler 线程，MainHandler线程从消息队列中获得该消息，通过handleMessage 方法来进入serviceTimeout过程，最终便是调用appNotResponding(...)方法。\n123handleMessage(...)    AS.serviceTimeout(...)        AMS.appNotResponding(...)\n  Service 运行在主线程里面，在 Service 里编写了非常耗时的代码会出现 ANR。可以在 Service 中再创建一个子线程，然后在这里去处理耗时逻辑，或者使用远程Service的方式。但是在使用远程Service的方式的时候，Service 和 Activity 不在同一个进程，这个时候，不能通过传统的方式来建立关联，需要使用 AIDL 来进行跨进程通信。远程服务是独立的进程，进程名格式为所在包名你指定的android:process字符串。\n","plink":"https://zhoufeichi.com/2018/02/13/ANR-Service/"},{"title":"Binder通信","date":"2018-02-12T03:23:13.000Z","date_formatted":{"ll":"Feb 12, 2018","L":"02/12/2018","MM-DD":"02-12"},"updated":"2020-04-04T05:59:18.673Z","content":"介绍\nTCP/IP五层通信架构\n\n应用层：直接为用户提供服务\n传输层：传输的是Segment报文段(TCP)或者Datagram数据报(UDP数据)\n网络层：传输的是Package包\n数据链路层：传输的是Frame帧\n物理层：传输的是Bit比特\n\nBinder IPC原理\n   Binder 通信采用C/S架构，包含Client、Server、Service Manager以及Binder驱动。其中ServiceManager用于管理系统中的各种服务。Client端和Server端通信时都需要先获取 Service Manager 接口。AMS需要通过Service Manager注册服务， Client端在使用AMS之前需要通过Service Manager获取服务，也就是首先获得AMS的代理类AMP。 获取到AMP代理类之后，就可以跟AMS通信了。\n  Client,Server,Service Manager之间不是直接交互的，都通过与 Binder Driver 进行交互的，从而实现 IPC 通信方式。其中 Binder 驱动位于内核空间，Client,Server,Service Manager位于用户空间。Binder 驱动和 Service Manager 可以看做是 Android 平台的基础架构，而 Client 和 Server 是 Android 的应用层。\n  不管是注册服务、请求服务还是使用服务，每次都会经历一个完整的 Binder IPC 的过程。\n","plink":"https://zhoufeichi.com/2018/02/12/Binder通信/"},{"title":"ContentProvider","date":"2018-02-12T03:04:41.000Z","date_formatted":{"ll":"Feb 12, 2018","L":"02/12/2018","MM-DD":"02-12"},"updated":"2020-04-04T05:59:18.673Z","content":"介绍\nContentProvider 是一个抽象类，当实现自己的 ContentProvider 类，只需继承于 ContentProvider ，并且实 现以下六个 abstract 方法即可：\n\ninsert(Uri, ContentValues)：插入新数据；\ndelete(Uri, String, String[])：删除已有数据；\nupdate(Uri, ContentValues, String, String[])：更新数据；\nquery(Uri, String[], String, String[], String)：查询数据；\nonCreate()：执行初始化工作；\ngetType(Uri)：获取数据MIME类型。\n\nContentProvider 的数据操作方法可以看出都依赖于 Uri ，例如content://com.philo.articles/android/contentprovider，其中：\n\ncontent:// ：作为前缀，这是 Uri 默认的固定开头格式\ncom.philo.articles ：作为授权，唯一标识 provider\n/android/contentprovider ：作为路径，标明具体的数据位置\n\n在 ContentProvider 中，\n\nCONTENT_PROVIDER_PUBLISH_TIMEOUT(10s)： provider 所在进程发布其 ContentProvider 的超时时长为10s，超过10s则会被系统所杀。\nmLaunchingProviders：记录的每一项是一个ContentProviderRecord对象, 所有的存在 client 等待其发布完成的contentProvider 列表，一旦发布完成则相应的 contentProvider 便会从该列表移除\nmProviderMap：记录该进程的contentProvider\n\n查询 ContentProvider\n  其他进程或者 app 如果想要操作 ContentProvider ，那么首先需要获取其对应的 ContentResolver ，再利用\nContentResolver 类来完成对数据的增删改查操作。\n12345ContentResolver cr = getContentResolver();  //获取ContentResolverUri uri = Uri.parse(&quot;content://com.philo.articles/android/contentprovider&quot;);Cursor cursor = cr.query(uri, null, null, null, null);  //执行查询操作...cursor.close(); //关闭\n  getContentResolver() 方法经过层层调用来到 ContextImpl 类，得到的返回值是在 ContextImpl 对象创建过程中就创建好的 ApplicationContentResolver 类型的对象。\n  而在 query() 方法中，首先调用ContentResolver.acquireUnstableProvider()方法，试图通过 uri 获取 unstableProvider 对象，CR.acquireUnstableProvider()方法是通过调用 ACR.acquireUnstableProvider()来实现的。ACR.acquireUnstableProvider()方法会返回一个 IContentProvider 类型的对象，而在该方法中，最终会调用到ActivityThread.acquireProvider()方法。\n12345678910CR.query(...)    CR.acquireUnstableProvider(...)        ACR.acquireUnstableProvider(...)            AT.acquireProvider(...)                AT.acquireExistingProvider(...)                AMP.getContentProvider(...)                    AMS.getContentProvider(...)                        AMS.getContentProviderImpl(...)                AT.installProvider(...)\n  在AT.acquireProvider()方法中，首先通过调用方法AT.acquireExistingProvider()尝试获取已存储的 provider ，当成功获取则直接返回，否则继续执行。在AT.acquireExistingProvider()中：\n\n首先从 ActivityThread 的 mProviderMap 查询是否存在相对应的 provider，若不存在则直接返回\n当 provider 记录存在,但其所在进程已经死亡，则调用handleUnstableProviderDiedLocked()清理 provider 信息, 并返回\n当 provider 记录存在,且进程存活的情况下,则在 provider 引用计数不为空时则继续增加引用计数\n\n  如果AT.acquireExistingProvider()没有成功获取到 provider 对象，那么需要通过AMP.getContentProvider()来获取 provider ，当无法获取 auth 所对应的 provider 则直接返回，否则继续执行。在AMP.getContentProvider()中，AMP经过 binder IPC 通信传递给 AMS 来完成相应工作, 因此接着执行AMS.getContentProvider()方法。在AMS.getContentProvider()方法中又会继续调用AMS.getContentProviderImpl()方法。AMS.getContentProviderImpl()方法中首先会获得调用者的进程记录 ProcessRecord ，接着从 AMS 中查询相应的 ContentProviderRecord 对象 cpr，\n1cpr = mProviderMap.getProviderByName(name, userId);\n  在这里，\n\nmProviderMap.putProviderByClass(comp, cpr): 以 ComponentName (组件名)为 key, ContentProviderRecord 为 value\nmProviderMap.putProviderByName(name, cpr): 以 auth (即com.philo.articles)为 key, ContentProviderRecord 为 value\n\n接下来就是需要判断目标 provider 的情况：\n\n目标 provider 已存在\n\n权限检查\n当允许运行在调用者进程且该 ContentProvider 已发布，则直接返回\n增加 provider 的引用计数\n更新进程 LRU 队列\n更新进程 adj\n当 provider 进程被杀时，则减少引用计数并调用appDiedLocked()，且设置 ContentProvider 为没有发布的状态\n\n\n目标 provider 不存在\n\n根据 authority，获取 ProviderInfo 对象；\n权限检查\n当 provider 不是运行在 system 进程，且系统未准备好，则抛出 IllegalArgumentException\n当拥有该 provider 的用户并没有运行，则直接返回\n根据 ComponentName，从 AMS.mProviderMap 中查询相应的 ContentProviderRecord\n当首次调用，则创建对象 ContentProviderRecord\n当允许运行在调用者进程且 ProcessRecord 不为空，则直接返回。该 ContentProvider 是否能运行在调用者所在 进程需要同时满足以下条件：\n\nContentProvider 在 AndroidManifest.xml 文件配置 multiprocess=true；或调用者进程与 ContentProvider 在同一个进程。\nContentProvider 进程跟调用者所在进程是同一个 uid。\n\n\n当 provider 并没有处于 mLaunchingProviders 队列，则启动它\n\n当 ProcessRecord 不为空，则加入到 pubProviders，并开始安装 provider;\n当 ProcessRecord 为空，则通过 startProcessLocked() 启动进程\n然后再将 cpr 添加到 mLaunchingProviders\n\n\n增加引用计数\n\n\n循环等待 provider 发布\n\n  到此处，AT.acquireProvider()方法应该已成功获取了 Provider 对象, 接下来便是在调用端安装 Provider ，接着就要调用AT.installProvider()方法来安装 provider ,并增加该 provider 的引用计数。\n123456AT.installProvider(...)    AMP.removeContentProvider(...)        AMS.removeContentProvider(...)            AMS.decProviderCountLocked(...)    AT.installProviderAuthoritiesLocked(...)    new ProviderRefCount(...)\n\n在需要释放引用时，会调用到AMP.removeContentProvider(...)方法，同样的这也是通过 binder 的通信方式，最终也会调用到AMS.removeContentProvider(...)方法，在AMS.removeContentProvider(...)方法中，调用了AMS.decProviderCountLocked(...) 方法，在该方法中判断当provider连接的 stable 和 unstable 引用次数都为0时,则移除该连接对象信息。与减小 provider 引用所相反的操作便是增加引用AMS.incProviderCountLocked(...) ，那么在这个方法中，首先在从当前进程所使用的 provider 中查询与目标 provider 一致的信息，接着判断 provider 是 stable 类型的还是 unstable 类型的，同时需要增加对应的引用计数。如果查询不到对应的 provider 连接对象，那么需要新建一个 provider 连接对象。\n如果不需要释放引用，那么会调用AT.installProviderAuthoritiesLocked(...)方法，\n\n  上述整个过程就是先试图获取 unstableProvider 对象，如果获取到的 unstableProvider 为空，直接返回。当获取到 unstableProvider 对象后，执行 query 操作。ContentProviderProxy.query()方法里通过调用mRemote.transact()方法发送给 Binder 服务端， Binder 服务端通过CPN.onTransact()交由Transport.query()处理， Transport 类继承 ContentProvider 类。到这里真正调用了目标 provider的query()方法。\n  在查询的过程中如果抛出 DeadObjectException 异常，那么表示 ContentProvider 所在进程死亡，接下来尝试 获取 stable 的 ContentProvider。\n\n先调用unstableProviderDied(), 清理刚创建的 unstable 的 ContentProvider\n调用acquireProvider()，尝试获取 stable 的 ContentProvider, 此时当 ContentProvider 进程死亡，则会杀掉该 ContentProvider 的客户端进程\n然后执行 query 操作\n\n  采用 unstable 类型的 ContentProvider 的 app 不会因为远程 ContentProvider 进程的死亡而被杀，stable 则恰恰相反。对于 app 无法事先决定创建的 ContentProvider 是 stable，还是 unstable 类型的，也便无法得知自己的进 程是否会依赖于远程 ContentProvider 的生死。\nProvider 进程\n  发布ContentProvider分两种情况：\n\nProvider进程尚未启动：system_server 进程调用 startProcessLocked()创建 provider 进程且 attach 到 system_server 后, 通过 binder 方式通知 provider 进程执行 AT.bindApplication()方法\n\n  执行AT.bindApplication()方法时，也是通过 handler 的通信方式，通过sendMessage()方法，主线程在handMessage()方法时，会调用AT.handleBindApplication()方法。\n1234567AT.handleBindApplication(...)    AT.installContentProvider(...)        AT.installProvider(...)            ContentProvider.getIContentProvider(...)        AMP.publishContentProviders(...)            AMS.publishContentProviders(...)    mInstrumentation.callApplicationOnCreate(...)\n  在AT.installProvider()方法中主要是通过反射，创建目标 ContentProvider 对象,并通过调用ContentProvider.getIContentProvider()得到创建的 ContentProvider 对象，并调用该对象 onCreate 方法.随后便是 publish 的过程，在 publish 的过程中，会 将该provider添加到 mProviderMap，并将该 provider 移出 mLaunchingProviders 队列。一旦 publish 成功,同时也会移除 provider 发布超时的消息,并且调用 notifyAll()来唤醒所有等待的 Client 端进程。 Provider进程的工作便是完成，接下来便开始执行 installProvider过程。\n\nProvider 进程已启动但未发布：发现 provider 进程已存在且 attach 到 system_server，但所对应的 provider 还没 有发布, 通过binder 方式通知 provider 进程执行 AT.scheduleInstallProvider()方法\n\n123456789AT.scheduleInstallProvider(...)    sendMessage(...)    AT.handleInstallProvider(...)        AT.installContentProvider(...)            AT.installProvider(...)                ContentProvider.getIContentProvider(...)            AMP.publishContentProviders(...)                AMS.publishContentProviders(...)        mInstrumentation.callApplicationOnCreate(...)\n  与 ContentProvider 相关的类中，有两个类， ContentProviderConnection 和 ProviderRefCount ，其中， ContentProviderConnection 是连接 ContentProvider 与 Client 之间的对象。在 ContentProviderConnection 中，\n\nprovider：用于保存目标 provider\nclient：请求该 provider 的客户端进程\nwaiting：布尔类型变量，用于记录该连接的 client 进程是否正在等待该 provider 发布\n\n而 ProviderRefCount 是 ActivityThread 的内部类，该引用保存到 Client 端。\n  进程 A 与另一进程 B 的 provider 建立通信时：\n\n对于 stable provider：会杀掉所有跟该 provider 建立 stable 连接的非 persistent 进程。若使用过程中，B crash 或者被砍掉了，则 A 立即被 ActivityManagerService 砍掉，进程 A 没有任何容错处理的机会\n对于 unstable provider：若使用过程中，B crash 或者被砍掉了，不会导致 client 进程 A 被级联所杀,只会回调 unstableProviderDied 来清理相关信息，可进行容错处理\n\n  stable provider 和 unstable provider，在于引用计数的不同，stable provider 建立的是强连接, 客户端进程与 provider 进程存在依赖关系, 即 provider 进程死亡则会导致客户端进程被杀。\n","plink":"https://zhoufeichi.com/2018/02/12/ContentProvider/"},{"title":"Broadcast广播机制","date":"2018-02-09T02:23:33.000Z","date_formatted":{"ll":"Feb 9, 2018","L":"02/09/2018","MM-DD":"02-09"},"updated":"2020-04-04T05:59:18.673Z","content":"介绍\n\n广播发送\n\n普通广播：通过Context.sendBroadcast()发送，可并行处理\n有序广播：通过Context.sendOrderedBroadcast()发送，串行处理\nSticky广播：通过Context.sendStickyBroadcast()发送，用此函数发送的广播会一直滞留，当有匹配此广播的广播接 收器被注册后，该广播接收器就会收到此条信息。\n\n\n广播接收(BroadcastReceiver)\n\n静态广播接收者：通过AndroidManifest.xml的标签来注册的BroadcastReceiver\n动态广播接收者：通过AMS.registerReceiver()方式注册的BroadcastReceiver，不需要的时候可以通过 unregisterReceiver()取消注册。\n\n\nBroadcastRecord\n  广播在系统中以BroadcastRecord对象来记录, BroadcastRecord的数据结构如下：\n\n12345678910111213141516    final class BroadcastRecord extends Binder &#123;    final ProcessRecord callerApp; //广播发送者所在进程    final String callerPackage; //广播发送者所在包名    final List receivers;   // 包括动态注册的BroadcastFilter和静态注册的ResolveInfo    final int callingPid;   // 广播发送者pid    int nextReceiver;  // 下一个被执行的接收者    IBinder receiver; // 当前正在处理的接收者    int anrCount;   //广播ANR次数    long enqueueClockTime;  //入队列时间    long dispatchTime;      //分发时间    long dispatchClockTime; //分发时间    long receiverTime;      //接收时间(首次等于dispatchClockTime)    long finishTime;        //广播完成时间&#125;\n  其中 enqueueClockTime 伴随着scheduleBroadcastsLocked，dispatchClockTime伴随着deliverToRegisteredReceiverLocked，finishTime位于addBroadcastToHistoryLocked方法内\n注册广播\n  注册广播通常是在Activity/Service中通过调用registerReceiver()的方式实现。而Activity或Service都间 接继承于Context抽象类，真正的实现是交给ContextImpl类。\n  首先通过调用CI.regitsterReceiver()方法来启动注册广播的流程，registerReceiver()有两个重载的方法:\n12345678public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) &#123;    return registerReceiver(receiver, filter, null, null);&#125;public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler) &#123;    return registerReceiverInternal(receiver, getUserId(),            filter, broadcastPermission, scheduler, getOuterContext());&#125;\n  其中broadcastPermission拥有广播的权限控制，scheduler用于指定接收到广播时onRecive执行线程，当scheduler=null则默认代表在主线程中执行，这也是最常见的用法。\n  在registerReceiver方法中，通过调用CI.registerReceiverInternal()方法，同时返回调用该方法后得到 的值。在CI.registerReceiverInternal()方法体中，首先会将主线程Handler赋给 scheduler，接着获取IIntentReceiver对象：\n1IIntentReceiver rd = mPackageInfo.getReceiverDispatcher(receiver, context, scheduler, mMainThread.getInstrumentation(), true);\n  在LoadedApk.getReceiverDispatcher()方法中，会试图获取到 LoadedApk.ReceiverDispatcher对象 rd 。如果广播发布者 rd 为空，那么会重新创建一个ReceiverDispatcher，ReceiverDispatcher对象中有一个内部类InnerReceiver，该内部类继承于IIntentReceiver.Stub，这是一个Binder服务端，广播发布者通过rd.getIIntentReceiver()可以获取到该 Binder服务端对象InnerReceiver用于Binder通信。得到ReceiverDispatcher对象 rd 后通过rd.getIIntentReceiver()来获得 IIntentReceiver 对象，同时将该对象返回。\n  前面部分已经得到一个IIntentReceiver对象 rd 了，接着在registerReceiverInternal方法中继续调用ActivityManagerNative.getDefault().registerReceiver()方法，ActivityManagerNative.getDefault()返回的是 ActivityManagerProxy对象，方法中参数mMainThread.getApplicationThread()返回的是ApplicationThread，这是Binder 的Bn端，用于system_server进程与该进程的通信。\n  接下来在AMP.registerReceiver()方法中，通过mRemote.transact()方法，AMP通过Binder驱动将传递来的信息发送给 system_server 进程中的 AMS 对象，接下来进入到AMS.registerReceiver()的执行过程中。\n  在AMS.registerReceiver()方法体中，首先会通过getRecordForAppLocked(caller)方法获得调用者的进程信息。并将获得的 ProcessRecord 对象赋值给 callerApp 。接来下，需要获得 IntentFilter 中的的 actions ，这就是所需 要监听的广播 action。\n1Iterator&lt;String&gt; actions = filter.actionsIterator();\n  接着判断注册的是不是sticky广播，首先需要根据用户id来获取所有的sticky intent，再根据action来获取符合该action的intent，同时将找到的intent加入到stickyIntents队列中。\n123456789101112131415161718int[] userIds = &#123; UserHandle.USER_ALL, UserHandle.getUserId(callingUid) &#125;;while (actions.hasNext()) &#123;    String action = actions.next();    for (int id : userIds) &#123;        //从mStickyBroadcasts中查看用户的sticky Intent        ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(id);        if (stickies != null) &#123;            ArrayList&lt;Intent&gt; intents = stickies.get(action);            if (intents != null) &#123;                if (stickyIntents == null) &#123;                    stickyIntents = new ArrayList&lt;Intent&gt;();                &#125;                //将sticky Intent加入到队列                stickyIntents.addAll(intents);            &#125;        &#125;    &#125;&#125;\n  继续往下走，还要继续通过IntentFilter.matcher()方法来继续匹配发起的Intent数据是否匹配成功。\n123456789101112131415ArrayList&lt;Intent&gt; allSticky = null;if (stickyIntents != null) &#123;    final ContentResolver resolver = mContext.getContentResolver();    for (int i = 0, N = stickyIntents.size(); i &lt; N; i++) &#123;        Intent intent = stickyIntents.get(i);        //查询匹配的sticky广播        if (filter.match(resolver, intent, true, TAG) &gt;= 0) &#123;            if (allSticky == null) &#123;                allSticky = new ArrayList&lt;Intent&gt;();            &#125;            //匹配成功，则将给intent添加到allSticky队列            allSticky.add(intent);        &#125;    &#125;&#125;\n  判断完是不是 sticky 广播之后，继续往下走，当广播 receiver 没有注册过，则创建广播接收者队列ReceiverList，该对象继承于ArrayList，并将创建的ReceiverList添加到已注册广播队列AMS.mRegisteredReceivers中。mRegisteredReceivers记录着所有已注册的广播，以receiver IBinder为 key, ReceiverList为 value 的 HashMap。 接者创建BroadcastFilter对象，并添加到AMS.mReceiverResolver队列中，以及刚才创建的ReceiverList中。\n  对于所有通过刚才操作匹配的 sticky 广播，接下来需要进行入队操作，根据这些sticky广播的 intent 来返回 前台或者后台广播队列。创建好BroadcastRecord之后，便可以把该创建好的BroadcastRecord添加到并行广播队列中。在 BroadcastQueue中有两个广播队列mParallelBroadcasts,mOrderedBroadcasts，数据类型都为ArrayList：\n\nmParallelBroadcasts:并行广播队列，可以立刻执行，而无需等待另一个广播运行完成，该队列只允许动态已注册的广播，从而避免发生同时拉起大量进程来执行广播，前台的和后台的广播分别位于独立的队列。\nmOrderedBroadcasts：有序广播队列，同一时间只允许执行一个广播，该队列顶部的广播便是活动广播，其他广播必须等待该广播结束才能运行，也是独立区别前台的和后台的广播。\n\n  broadcastQueueForIntent(Intent intent)通过判断intent.getFlags()是否包含 FLAG_RECEIVER_FOREGROUND 来决定是前台或后台广播，进而返回相应的广播队列 mFgBroadcastQueue 或者 mBgBroadcastQueue。\n\n当 Intent 的 flags 包含 FLAG_RECEIVER_FOREGROUND，则返回 mFgBroadcastQueue；\n当 Intent 的 flags 不包含 FLAG_RECEIVER_FOREGROUND，则返回 mBgBroadcastQueue；\n\n发送广播\n  发送广播是在Activity和Service中通过调用sendBroadcast()，因此实际上也是通过ContextImpl类来实现的。在CI.sendBroadcast(Intent intent)方法中，调用了AMP.broadcastIntent()，在AMP.broadcastIntent()中，通过mRemote.transact()方法，AMP通过Binder驱动将传递来的信息发送给system_server进程中的AMS对象，接下来进入到AMS.broadcastIntent()的执行过程中。\n  在AMS.broadcastIntent()方法中，通过传进来的两个布尔参数serialized和sticky来共同决定是普通广播， 有序广播,还是Sticky广播。在方法体中首先验证广播intent是否有效，获取调用者进程记录对象，接着调用AMS.broadcastIntentLocked。\n  在AMS.broadcastIntentLocked中首先需要设置广播 flag ,添加flag=FLAG_EXCLUDE_STOPPED_PACKAGES，保证已停止app不会收到该广播。当系统还没有启动完成，则不允许启动新进程，即只有动态注册 receiver 才能接受广播。当非USER_ALL广播且当前用户并没有处于Running的情况下，除非是系统升级广播或者关机广播，否则直接返回。\n  设置完flag之后进行广播权限验证，对于callingAppId为SYSTEM_UID，PHONE_UID，SHELL_UID，BLUETOOTH_UID，NFC_UID之一或者callingUid == 0时都畅通无阻。否则当调用者进程为空或者非persistent进程的情况下：\n\n当发送的是受保护广播mProtectedBroadcasts(只允许系统使用)，则抛出异常；\n当action为ACTION_APPWIDGET_CONFIGURE时，虽然不希望该应用发送这种广播，处于兼容性考虑，限制该广播只允许发送 给自己，否则抛出异常。\n\n  接着就是处理系统相关广播和增加sticky广播，将sticky广播增加到list，并放入mStickyBroadcasts里面。接下来查询receivers和registeredReceivers，当广播的intent没有设置FLAG_RECEIVER_REGISTERED_ONLY，则允许静态广播接收者来处理该广播，receivers记录着匹配当前intent的所有静态注册广播接收者。registeredReceivers记录着匹配当前的所有动态注册的广播接收者。\n  接着处理并行广播，处理并行广播主要是针对动态已注册的广播者，因此首先会获取到 registeredReceivers 中广播的数目。根据动态已注册的广播接受者的信息创建BroadcastRecord，将该BroadcastRecord加入到并行广播队列，在广播队列中有一个ArrayList类型的成员变量 mParallelBroadcasts 来维护所有的并行广播，然后接着调用 BroadcastQueue 的scheduleBroadcastsLocked方法来完成的不同广播的处理。\n  处理完并行广播之后，将 registerReceivers 合并到 receivers ，合并的过程中会比较优先级。合并完之后再 统一按串行方式处理，处理串行广播的过程中，也是先创建一个 BroadcastRecord 对象，然后将该 BroadcastRecord 对象加入到 有序广播队列中，在广播队列中有一个ArrayList类型的成员变量 mOrderedBroadcasts 来维护所有的有序广播同样的接着调 用 BroadcastQueue 的scheduleBroadcastsLocked方法来完成的不同广播的处理。\n处理广播\n  广播的处理是通过执行scheduleBroadcastsLocked方法来进行处理的。在该方法中，首先根据mBroadcastsScheduled来判断此时是否正在处理BROADCAST_INTENT_MSG消息，如果是，那么直接返回。否则，则通过 sendMessage 的方式来发送BROADCAST_INTENT_MSG消息，同时修改mBroadcastsScheduled的值为 true。在 BroadcastQueue 对象创建时，就会绑定一个 Looper 对象，接下来交由 mHandler 的handleMessage来处理。在handleMessage方法中，调用了processNextBroadcast方法。\n  首先处理并行广播，通过while循环, 一次性分发完所有的并发广播后,分发完成后则添加到历史广播队列。 分 发广播给已注册的 receiver 是通过调用deliverToRegisteredReceiverLocked()来实现的。下一步处理串行广播，首先会 获取所有该广播的接受者。同时如果广播处理时间超时，那么会强制结束这条广播。正常情况，继续往下通过调用performReceiveLocked()方法处理广播消息，处理完之后会取消BROADCAST_TIMEOUT_MSG消息。接着获取下条有序广播，在 这个过程中，首先设置广播超时时间，然后获取下一个广播接收者。如果该广播接收者是动态注册的，那么直接调用deliverToRegisteredReceiverLocked()方法来处理广播就好，对于静态注册的广播，会进行各种权限检测，权限不满足时会 设置skip = true，接着在后面会执行\n1234567if (skip) &#123;    r.receiver = null;    r.curFilter = null;    r.state = BroadcastRecord.IDLE;    scheduleBroadcastsLocked();    return;&#125;\n  接着处理下条有序广播，如果广播接受者所在进程已经运行，则调用方法processCurBroadcastLocked(r, app)直接处理，如果 receiver 所对应的进程尚未启动，则调用startProcessLocked()创建该进程，如果创建失败，那么结束该 receiver，同时重新调用scheduleBroadcastsLocked()，如果线程创建成功，则将重新将这个 BroadcastRecord 对象加入 到 mPendingBroadcast 中，以便下次处理有序广播时继续处理该对象。\n  在deliverToRegisteredReceiverLocked方法中，首先检查发送者是否有BroadcastFilter所需权限，以及接收者是否有发送者所需的权限等等，当权限都满足时，接着执行performReceiveLocked()方法。在这个方法里，通过binder 机制，通过ATP.scheduleRegisteredReceiver()向receiver 发送intent。ATP位于 system_server 进程，是 Binder Bp 端通过 Binder 驱动向 Binder Bn 端发送消息, ATP所对应的Bn 端位于发送广播调用端所在进程的 ApplicationThread， 即 进入AT.scheduleRegisteredReceiver，在该方法里继续调用InnerReceiver.performReceive()方法，在performReceive()方法里会调用ReceiverDispatcher.performReceive()，在ReceiverDispatcher.performReceive()方法里，首先会构造 参数 args。再通过 post() 的方式把消息放入 MessageQueue，再调用 Args 的 run() 方法。\n123Args args = new Args(intent, resultCode, data, extras, ordered, sticky, sendingUser);//通过handler消息机制发送args.mActivityThread.post(args)\n  在 run() 方法中，便进入了主线程，最终调用 BroadcastReceiver 具体实现类的 onReceiver() 方法。最后会 执行PengdingResult.finish()方法。在 finish() 方法中，对于\n\n静态注册的广播接收者:\n\n当 QueuedWork 工作未完成, 即 SharedPreferences 写入磁盘的操作没有完成, 则等待完成再执行 sendFinished 方法\n当 QueuedWork 工作已完成, 则直接调用 sendFinished 方法\n\n\n动态注册的广播接收者:\n\n当发送的是串行广播, 则直接调用 sendFinished 方法\n\n\n\n  接着便是sendFinished()方法。在sendFinished()方法中，调用了AMP.finishReceiver()方法，最终通过 binder 的通信方式，进入AMS.finishReceiver()方法中，最终调用BroadcastQueue.finishReceiverLocked()方法以及调\n用processNextBroadcast继续处理下一条广播。\n","plink":"https://zhoufeichi.com/2018/02/09/Broadcast广播机制/"}]