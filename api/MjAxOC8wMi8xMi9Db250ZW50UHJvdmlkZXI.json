{"title":"ContentProvider","date":"2018-02-12T03:04:41.000Z","date_formatted":{"ll":"Feb 12, 2018","L":"02/12/2018","MM-DD":"02-12"},"link":"2018/02/12/ContentProvider","tags":["Android","四大组件"],"categories":["笔记"],"updated":"2020-04-04T05:59:18.673Z","content":"<h5 id=\"介绍\">介绍<a title=\"#介绍\" href=\"#介绍\"></a></h5>\n<p>ContentProvider 是一个抽象类，当实现自己的 ContentProvider 类，只需继承于 ContentProvider ，并且实 现以下六个 abstract 方法即可：</p>\n<ul>\n<li>insert(Uri, ContentValues)：插入新数据；</li>\n<li>delete(Uri, String, String[])：删除已有数据；</li>\n<li>update(Uri, ContentValues, String, String[])：更新数据；</li>\n<li>query(Uri, String[], String, String[], String)：查询数据；</li>\n<li>onCreate()：执行初始化工作；</li>\n<li>getType(Uri)：获取数据MIME类型。</li>\n</ul>\n<p>ContentProvider 的数据操作方法可以看出都依赖于 Uri ，例如<code>content://com.philo.articles/android/contentprovider</code>，其中：</p>\n<ul>\n<li>content:// ：作为前缀，这是 Uri 默认的固定开头格式</li>\n<li>com.philo.articles ：作为授权，唯一标识 provider</li>\n<li>/android/contentprovider ：作为路径，标明具体的数据位置</li>\n</ul>\n<p>在 ContentProvider 中，</p>\n<ul>\n<li>CONTENT_PROVIDER_PUBLISH_TIMEOUT(10s)： provider 所在进程发布其 ContentProvider 的超时时长为10s，超过10s则会被系统所杀。</li>\n<li>mLaunchingProviders：记录的每一项是一个ContentProviderRecord对象, 所有的存在 client 等待其发布完成的contentProvider 列表，一旦发布完成则相应的 contentProvider 便会从该列表移除</li>\n<li>mProviderMap：记录该进程的contentProvider</li>\n</ul>\n<h5 id=\"查询-contentprovider\">查询 ContentProvider<a title=\"#查询-contentprovider\" href=\"#查询-contentprovider\"></a></h5>\n<p>  其他进程或者 app 如果想要操作 ContentProvider ，那么首先需要获取其对应的 ContentResolver ，再利用<br>\nContentResolver 类来完成对数据的增删改查操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ContentResolver</span> <span class=\"variable\">cr</span> <span class=\"operator\">=</span> getContentResolver();  <span class=\"comment\">//获取ContentResolver</span></span><br><span class=\"line\"><span class=\"type\">Uri</span> <span class=\"variable\">uri</span> <span class=\"operator\">=</span> Uri.parse(<span class=\"string\">&quot;content://com.philo.articles/android/contentprovider&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Cursor</span> <span class=\"variable\">cursor</span> <span class=\"operator\">=</span> cr.query(uri, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);  <span class=\"comment\">//执行查询操作</span></span><br><span class=\"line\">...</span><br><span class=\"line\">cursor.close(); <span class=\"comment\">//关闭</span></span><br></pre></td></tr></table></figure>\n<p>  <code>getContentResolver()</code> 方法经过层层调用来到 ContextImpl 类，得到的返回值是在 ContextImpl 对象创建过程中就创建好的 ApplicationContentResolver 类型的对象。<br>\n  而在 query() 方法中，首先调用<code>ContentResolver.acquireUnstableProvider()</code>方法，试图通过 uri 获取 unstableProvider 对象，<code>CR.acquireUnstableProvider()</code>方法是通过调用 <code>ACR.acquireUnstableProvider()</code>来实现的。<code>ACR.acquireUnstableProvider()</code>方法会返回一个 IContentProvider 类型的对象，而在该方法中，最终会调用到<code>ActivityThread.acquireProvider()</code>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CR.query(...)</span><br><span class=\"line\">    CR.acquireUnstableProvider(...)</span><br><span class=\"line\">        ACR.acquireUnstableProvider(...)</span><br><span class=\"line\">            AT.acquireProvider(...)</span><br><span class=\"line\">                AT.acquireExistingProvider(...)</span><br><span class=\"line\">                AMP.getContentProvider(...)</span><br><span class=\"line\">                    AMS.getContentProvider(...)</span><br><span class=\"line\">                        AMS.getContentProviderImpl(...)</span><br><span class=\"line\">                AT.installProvider(...)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  在<code>AT.acquireProvider()</code>方法中，首先通过调用方法<code>AT.acquireExistingProvider()</code>尝试获取已存储的 provider ，当成功获取则直接返回，否则继续执行。在<code>AT.acquireExistingProvider()</code>中：</p>\n<ul>\n<li>首先从 ActivityThread 的 mProviderMap 查询是否存在相对应的 provider，若不存在则直接返回</li>\n<li>当 provider 记录存在,但其所在进程已经死亡，则调用<code>handleUnstableProviderDiedLocked()</code>清理 provider 信息, 并返回</li>\n<li>当 provider 记录存在,且进程存活的情况下,则在 provider 引用计数不为空时则继续增加引用计数</li>\n</ul>\n<p>  如果<code>AT.acquireExistingProvider()</code>没有成功获取到 provider 对象，那么需要通过<code>AMP.getContentProvider()</code>来获取 provider ，当无法获取 auth 所对应的 provider 则直接返回，否则继续执行。在<code>AMP.getContentProvider()</code>中，AMP经过 binder IPC 通信传递给 AMS 来完成相应工作, 因此接着执行<code>AMS.getContentProvider()</code>方法。在<code>AMS.getContentProvider()</code>方法中又会继续调用<code>AMS.getContentProviderImpl()</code>方法。<code>AMS.getContentProviderImpl()</code>方法中首先会获得调用者的进程记录 ProcessRecord ，接着从 AMS 中查询相应的 ContentProviderRecord 对象 cpr，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cpr = mProviderMap.getProviderByName(name, userId);</span><br></pre></td></tr></table></figure>\n<p>  在这里，</p>\n<ul>\n<li>mProviderMap.putProviderByClass(comp, cpr): 以 ComponentName (组件名)为 key, ContentProviderRecord 为 value</li>\n<li>mProviderMap.putProviderByName(name, cpr): 以 auth (即com.philo.articles)为 key, ContentProviderRecord 为 value</li>\n</ul>\n<p>接下来就是需要判断目标 provider 的情况：</p>\n<ul>\n<li>目标 provider 已存在\n<ul>\n<li>权限检查</li>\n<li>当允许运行在调用者进程且该 ContentProvider 已发布，则直接返回</li>\n<li>增加 provider 的引用计数</li>\n<li>更新进程 LRU 队列</li>\n<li>更新进程 adj</li>\n<li>当 provider 进程被杀时，则减少引用计数并调用<code>appDiedLocked()</code>，且设置 ContentProvider 为没有发布的状态</li>\n</ul>\n</li>\n<li>目标 provider 不存在\n<ul>\n<li>根据 authority，获取 ProviderInfo 对象；</li>\n<li>权限检查</li>\n<li>当 provider 不是运行在 system 进程，且系统未准备好，则抛出 IllegalArgumentException</li>\n<li>当拥有该 provider 的用户并没有运行，则直接返回</li>\n<li>根据 ComponentName，从 AMS.mProviderMap 中查询相应的 ContentProviderRecord</li>\n<li>当首次调用，则创建对象 ContentProviderRecord</li>\n<li>当允许运行在调用者进程且 ProcessRecord 不为空，则直接返回。该 ContentProvider 是否能运行在调用者所在 进程需要同时满足以下条件：\n<ul>\n<li>ContentProvider 在 AndroidManifest.xml 文件配置 multiprocess=true；或调用者进程与 ContentProvider 在同一个进程。</li>\n<li>ContentProvider 进程跟调用者所在进程是同一个 uid。</li>\n</ul>\n</li>\n<li>当 provider 并没有处于 mLaunchingProviders 队列，则启动它\n<ul>\n<li>当 ProcessRecord 不为空，则加入到 pubProviders，并开始安装 provider;</li>\n<li>当 ProcessRecord 为空，则通过 <code>startProcessLocked()</code> 启动进程</li>\n<li>然后再将 cpr 添加到 mLaunchingProviders</li>\n</ul>\n</li>\n<li>增加引用计数</li>\n</ul>\n</li>\n<li>循环等待 provider 发布</li>\n</ul>\n<p>  到此处，<code>AT.acquireProvider()</code>方法应该已成功获取了 Provider 对象, 接下来便是在调用端安装 Provider ，接着就要调用<code>AT.installProvider()</code>方法来安装 provider ,并增加该 provider 的引用计数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AT.installProvider(...)</span><br><span class=\"line\">    AMP.removeContentProvider(...)</span><br><span class=\"line\">        AMS.removeContentProvider(...)</span><br><span class=\"line\">            AMS.decProviderCountLocked(...)</span><br><span class=\"line\">    AT.installProviderAuthoritiesLocked(...)</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">ProviderRefCount</span>(...)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在需要释放引用时，会调用到<code>AMP.removeContentProvider(...)</code>方法，同样的这也是通过 binder 的通信方式，最终也会调用到<code>AMS.removeContentProvider(...)</code>方法，在<code>AMS.removeContentProvider(...)</code>方法中，调用了<code>AMS.decProviderCountLocked(...)</code> 方法，在该方法中判断当provider连接的 stable 和 unstable 引用次数都为0时,则移除该连接对象信息。与减小 provider 引用所相反的操作便是增加引用<code>AMS.incProviderCountLocked(...)</code> ，那么在这个方法中，首先在从当前进程所使用的 provider 中查询与目标 provider 一致的信息，接着判断 provider 是 stable 类型的还是 unstable 类型的，同时需要增加对应的引用计数。如果查询不到对应的 provider 连接对象，那么需要新建一个 provider 连接对象。</li>\n<li>如果不需要释放引用，那么会调用<code>AT.installProviderAuthoritiesLocked(...)</code>方法，</li>\n</ul>\n<p>  上述整个过程就是先试图获取 unstableProvider 对象，如果获取到的 unstableProvider 为空，直接返回。当获取到 unstableProvider 对象后，执行 query 操作。<code>ContentProviderProxy.query()</code>方法里通过调用<code>mRemote.transact()</code>方法发送给 Binder 服务端， Binder 服务端通过<code>CPN.onTransact()</code>交由<code>Transport.query()</code>处理， Transport 类继承 ContentProvider 类。到这里真正调用了目标 provider的<code>query()</code>方法。</p>\n<p>  在查询的过程中如果抛出 DeadObjectException 异常，那么表示 ContentProvider 所在进程死亡，接下来尝试 获取 stable 的 ContentProvider。</p>\n<ul>\n<li>先调用<code>unstableProviderDied()</code>, 清理刚创建的 unstable 的 ContentProvider</li>\n<li>调用<code>acquireProvider()</code>，尝试获取 stable 的 ContentProvider, 此时当 ContentProvider 进程死亡，则会杀掉该 ContentProvider 的客户端进程</li>\n<li>然后执行 query 操作</li>\n</ul>\n<p>  采用 unstable 类型的 ContentProvider 的 app 不会因为远程 ContentProvider 进程的死亡而被杀，stable 则恰恰相反。对于 app 无法事先决定创建的 ContentProvider 是 stable，还是 unstable 类型的，也便无法得知自己的进 程是否会依赖于远程 ContentProvider 的生死。</p>\n<h5 id=\"provider-进程\">Provider 进程<a title=\"#provider-进程\" href=\"#provider-进程\"></a></h5>\n<p>  发布ContentProvider分两种情况：</p>\n<ul>\n<li>Provider进程尚未启动：system_server 进程调用 <code>startProcessLocked()</code>创建 provider 进程且 attach 到 system_server 后, 通过 binder 方式通知 provider 进程执行 <code>AT.bindApplication()</code>方法</li>\n</ul>\n<p>  执行<code>AT.bindApplication()</code>方法时，也是通过 handler 的通信方式，通过<code>sendMessage()</code>方法，主线程在<code>handMessage()</code>方法时，会调用<code>AT.handleBindApplication()</code>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AT.handleBindApplication(...)</span><br><span class=\"line\">    AT.installContentProvider(...)</span><br><span class=\"line\">        AT.installProvider(...)</span><br><span class=\"line\">            ContentProvider.getIContentProvider(...)</span><br><span class=\"line\">        AMP.publishContentProviders(...)</span><br><span class=\"line\">            AMS.publishContentProviders(...)</span><br><span class=\"line\">    mInstrumentation.callApplicationOnCreate(...)</span><br></pre></td></tr></table></figure>\n<p>  在<code>AT.installProvider()</code>方法中主要是通过反射，创建目标 ContentProvider 对象,并通过调用<code>ContentProvider.getIContentProvider()</code>得到创建的 ContentProvider 对象，并调用该对象 onCreate 方法.随后便是 publish 的过程，在 publish 的过程中，会 将该provider添加到 mProviderMap，并将该 provider 移出 mLaunchingProviders 队列。一旦 publish 成功,同时也会移除 provider 发布超时的消息,并且调用 <code>notifyAll()</code>来唤醒所有等待的 Client 端进程。 Provider进程的工作便是完成，接下来便开始执行 installProvider过程。</p>\n<ul>\n<li>Provider 进程已启动但未发布：发现 provider 进程已存在且 attach 到 system_server，但所对应的 provider 还没 有发布, 通过binder 方式通知 provider 进程执行 <code>AT.scheduleInstallProvider()</code>方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AT.scheduleInstallProvider(...)</span><br><span class=\"line\">    sendMessage(...)</span><br><span class=\"line\">    AT.handleInstallProvider(...)</span><br><span class=\"line\">        AT.installContentProvider(...)</span><br><span class=\"line\">            AT.installProvider(...)</span><br><span class=\"line\">                ContentProvider.getIContentProvider(...)</span><br><span class=\"line\">            AMP.publishContentProviders(...)</span><br><span class=\"line\">                AMS.publishContentProviders(...)</span><br><span class=\"line\">        mInstrumentation.callApplicationOnCreate(...)</span><br></pre></td></tr></table></figure>\n<p>  与 ContentProvider 相关的类中，有两个类， ContentProviderConnection 和 ProviderRefCount ，其中， ContentProviderConnection 是连接 ContentProvider 与 Client 之间的对象。在 ContentProviderConnection 中，</p>\n<ul>\n<li>provider：用于保存目标 provider</li>\n<li>client：请求该 provider 的客户端进程</li>\n<li>waiting：布尔类型变量，用于记录该连接的 client 进程是否正在等待该 provider 发布</li>\n</ul>\n<p>而 ProviderRefCount 是 ActivityThread 的内部类，该引用保存到 Client 端。</p>\n<p>  进程 A 与另一进程 B 的 provider 建立通信时：</p>\n<ul>\n<li>对于 stable provider：会杀掉所有跟该 provider 建立 stable 连接的非 persistent 进程。若使用过程中，B crash 或者被砍掉了，则 A 立即被 ActivityManagerService 砍掉，进程 A 没有任何容错处理的机会</li>\n<li>对于 unstable provider：若使用过程中，B crash 或者被砍掉了，不会导致 client 进程 A 被级联所杀,只会回调 unstableProviderDied 来清理相关信息，可进行容错处理</li>\n</ul>\n<p>  stable provider 和 unstable provider，在于引用计数的不同，stable provider 建立的是强连接, 客户端进程与 provider 进程存在依赖关系, 即 provider 进程死亡则会导致客户端进程被杀。</p>\n","prev":{"title":"Binder通信","link":"2018/02/12/Binder通信"},"next":{"title":"Broadcast广播机制","link":"2018/02/09/Broadcast广播机制"},"plink":"https://zhoufeichi.com/2018/02/12/ContentProvider/","reward":true,"reading_time":"2234 words in 15 min"}