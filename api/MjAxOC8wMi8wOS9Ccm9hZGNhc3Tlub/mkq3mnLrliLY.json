{"title":"Broadcast广播机制","date":"2018-02-09T02:23:33.000Z","date_formatted":{"ll":"Feb 9, 2018","L":"02/09/2018","MM-DD":"02-09"},"link":"2018/02/09/Broadcast广播机制","tags":["Android","四大组件"],"categories":["笔记"],"updated":"2020-04-04T05:59:18.673Z","content":"<h5 id=\"介绍\">介绍<a title=\"#介绍\" href=\"#介绍\"></a></h5>\n<ul>\n<li>广播发送\n<ul>\n<li>普通广播：通过Context.sendBroadcast()发送，可并行处理</li>\n<li>有序广播：通过Context.sendOrderedBroadcast()发送，串行处理</li>\n<li>Sticky广播：通过Context.sendStickyBroadcast()发送，用此函数发送的广播会一直滞留，当有匹配此广播的广播接 收器被注册后，该广播接收器就会收到此条信息。</li>\n</ul>\n</li>\n<li>广播接收(BroadcastReceiver)\n<ul>\n<li>静态广播接收者：通过AndroidManifest.xml的标签来注册的BroadcastReceiver</li>\n<li>动态广播接收者：通过AMS.registerReceiver()方式注册的BroadcastReceiver，不需要的时候可以通过 unregisterReceiver()取消注册。</li>\n</ul>\n</li>\n<li>BroadcastRecord<br>\n  广播在系统中以BroadcastRecord对象来记录, BroadcastRecord的数据结构如下：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BroadcastRecord</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Binder</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ProcessRecord callerApp; <span class=\"comment\">//广播发送者所在进程</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String callerPackage; <span class=\"comment\">//广播发送者所在包名</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> List receivers;   <span class=\"comment\">// 包括动态注册的BroadcastFilter和静态注册的ResolveInfo</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">int</span> callingPid;   <span class=\"comment\">// 广播发送者pid</span></span><br><span class=\"line\">    <span class=\"type\">int</span> nextReceiver;  <span class=\"comment\">// 下一个被执行的接收者</span></span><br><span class=\"line\">    IBinder receiver; <span class=\"comment\">// 当前正在处理的接收者</span></span><br><span class=\"line\">    <span class=\"type\">int</span> anrCount;   <span class=\"comment\">//广播ANR次数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">long</span> enqueueClockTime;  <span class=\"comment\">//入队列时间</span></span><br><span class=\"line\">    <span class=\"type\">long</span> dispatchTime;      <span class=\"comment\">//分发时间</span></span><br><span class=\"line\">    <span class=\"type\">long</span> dispatchClockTime; <span class=\"comment\">//分发时间</span></span><br><span class=\"line\">    <span class=\"type\">long</span> receiverTime;      <span class=\"comment\">//接收时间(首次等于dispatchClockTime)</span></span><br><span class=\"line\">    <span class=\"type\">long</span> finishTime;        <span class=\"comment\">//广播完成时间</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  其中 enqueueClockTime 伴随着scheduleBroadcastsLocked，dispatchClockTime伴随着deliverToRegisteredReceiverLocked，finishTime位于addBroadcastToHistoryLocked方法内</p>\n<h5 id=\"注册广播\">注册广播<a title=\"#注册广播\" href=\"#注册广播\"></a></h5>\n<p>  注册广播通常是在Activity/Service中通过调用<code>registerReceiver()</code>的方式实现。而Activity或Service都间 接继承于Context抽象类，真正的实现是交给ContextImpl类。</p>\n<p>  首先通过调用<code>CI.regitsterReceiver()</code>方法来启动注册广播的流程，registerReceiver()有两个重载的方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Intent <span class=\"title function_\">registerReceiver</span><span class=\"params\">(BroadcastReceiver receiver, IntentFilter filter)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> registerReceiver(receiver, filter, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> Intent <span class=\"title function_\">registerReceiver</span><span class=\"params\">(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> registerReceiverInternal(receiver, getUserId(),</span><br><span class=\"line\">            filter, broadcastPermission, scheduler, getOuterContext());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  其中<code>broadcastPermission</code>拥有广播的权限控制，scheduler用于指定接收到广播时onRecive执行线程，当<code>scheduler=null</code>则默认代表在主线程中执行，这也是最常见的用法。</p>\n<p>  在<code>registerReceiver</code>方法中，通过调用<code>CI.registerReceiverInternal()</code>方法，同时返回调用该方法后得到 的值。在<code>CI.registerReceiverInternal()</code>方法体中，首先会将主线程Handler赋给 scheduler，接着获取<code>IIntentReceiver</code>对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">IIntentReceiver</span> <span class=\"variable\">rd</span> <span class=\"operator\">=</span> mPackageInfo.getReceiverDispatcher(receiver, context, scheduler, mMainThread.getInstrumentation(), <span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n<p>  在<code>LoadedApk.getReceiverDispatcher()</code>方法中，会试图获取到 <code>LoadedApk.ReceiverDispatcher</code>对象 rd 。如果广播发布者 rd 为空，那么会重新创建一个<code>ReceiverDispatcher</code>，<code>ReceiverDispatcher</code>对象中有一个内部类<code>InnerReceiver</code>，该内部类继承于<code>IIntentReceiver.Stub</code>，这是一个Binder服务端，广播发布者通过<code>rd.getIIntentReceiver()</code>可以获取到该 Binder服务端对象<code>InnerReceiver</code>用于Binder通信。得到<code>ReceiverDispatcher</code>对象 rd 后通过<code>rd.getIIntentReceiver()</code>来获得 IIntentReceiver 对象，同时将该对象返回。</p>\n<p>  前面部分已经得到一个<code>IIntentReceiver</code>对象 rd 了，接着在<code>registerReceiverInternal</code>方法中继续调用<code>ActivityManagerNative.getDefault().registerReceiver()</code>方法，<code>ActivityManagerNative.getDefault()</code>返回的是 <code>ActivityManagerProxy</code>对象，方法中参数<code>mMainThread.getApplicationThread()</code>返回的是ApplicationThread，这是Binder 的Bn端，用于system_server进程与该进程的通信。</p>\n<p>  接下来在<code>AMP.registerReceiver()</code>方法中，通过<code>mRemote.transact()</code>方法，AMP通过Binder驱动将传递来的信息发送给 system_server 进程中的 AMS 对象，接下来进入到<code>AMS.registerReceiver()</code>的执行过程中。</p>\n<p>  在<code>AMS.registerReceiver()</code>方法体中，首先会通过<code>getRecordForAppLocked(caller)</code>方法获得调用者的进程信息。并将获得的 ProcessRecord 对象赋值给 callerApp 。接来下，需要获得 IntentFilter 中的的 actions ，这就是所需 要监听的广播 action。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Iterator&lt;String&gt; actions = filter.actionsIterator();</span><br></pre></td></tr></table></figure>\n<p>  接着判断注册的是不是sticky广播，首先需要根据用户id来获取所有的sticky intent，再根据action来获取符合该action的intent，同时将找到的intent加入到stickyIntents队列中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[] userIds = &#123; UserHandle.USER_ALL, UserHandle.getUserId(callingUid) &#125;;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (actions.hasNext()) &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">action</span> <span class=\"operator\">=</span> actions.next();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> id : userIds) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//从mStickyBroadcasts中查看用户的sticky Intent</span></span><br><span class=\"line\">        ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(id);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stickies != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            ArrayList&lt;Intent&gt; intents = stickies.get(action);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (intents != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (stickyIntents == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    stickyIntents = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Intent&gt;();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//将sticky Intent加入到队列</span></span><br><span class=\"line\">                stickyIntents.addAll(intents);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  继续往下走，还要继续通过<code>IntentFilter.matcher()</code>方法来继续匹配发起的Intent数据是否匹配成功。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;Intent&gt; allSticky = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (stickyIntents != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ContentResolver</span> <span class=\"variable\">resolver</span> <span class=\"operator\">=</span> mContext.getContentResolver();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, N = stickyIntents.size(); i &lt; N; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">Intent</span> <span class=\"variable\">intent</span> <span class=\"operator\">=</span> stickyIntents.get(i);</span><br><span class=\"line\">        <span class=\"comment\">//查询匹配的sticky广播</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (filter.match(resolver, intent, <span class=\"literal\">true</span>, TAG) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (allSticky == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                allSticky = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Intent&gt;();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//匹配成功，则将给intent添加到allSticky队列</span></span><br><span class=\"line\">            allSticky.add(intent);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  判断完是不是 sticky 广播之后，继续往下走，当广播 receiver 没有注册过，则创建广播接收者队列<code>ReceiverList</code>，该对象继承于<code>ArrayList</code>，并将创建的<code>ReceiverList</code>添加到已注册广播队列<code>AMS.mRegisteredReceivers</code>中。<code>mRegisteredReceivers</code>记录着所有已注册的广播，以<code>receiver IBinder</code>为 key, <code>ReceiverList</code>为 value 的 HashMap。 接者创建<code>BroadcastFilter</code>对象，并添加到<code>AMS.mReceiverResolver</code>队列中，以及刚才创建的<code>ReceiverList</code>中。</p>\n<p>  对于所有通过刚才操作匹配的 sticky 广播，接下来需要进行入队操作，根据这些sticky广播的 intent 来返回 前台或者后台广播队列。创建好<code>BroadcastRecord</code>之后，便可以把该创建好的<code>BroadcastRecord</code>添加到并行广播队列中。在 BroadcastQueue中有两个广播队列mParallelBroadcasts,mOrderedBroadcasts，数据类型都为ArrayList：</p>\n<ul>\n<li>mParallelBroadcasts:并行广播队列，可以立刻执行，而无需等待另一个广播运行完成，该队列只允许动态已注册的广播，从而避免发生同时拉起大量进程来执行广播，前台的和后台的广播分别位于独立的队列。</li>\n<li>mOrderedBroadcasts：有序广播队列，同一时间只允许执行一个广播，该队列顶部的广播便是活动广播，其他广播必须等待该广播结束才能运行，也是独立区别前台的和后台的广播。</li>\n</ul>\n<p>  <code>broadcastQueueForIntent(Intent intent)</code>通过判断<code>intent.getFlags()</code>是否包含 FLAG_RECEIVER_FOREGROUND 来决定是前台或后台广播，进而返回相应的广播队列 mFgBroadcastQueue 或者 mBgBroadcastQueue。</p>\n<ul>\n<li>当 Intent 的 flags 包含 FLAG_RECEIVER_FOREGROUND，则返回 mFgBroadcastQueue；</li>\n<li>当 Intent 的 flags 不包含 FLAG_RECEIVER_FOREGROUND，则返回 mBgBroadcastQueue；</li>\n</ul>\n<h5 id=\"发送广播\">发送广播<a title=\"#发送广播\" href=\"#发送广播\"></a></h5>\n<p>  发送广播是在Activity和Service中通过调用<code>sendBroadcast()</code>，因此实际上也是通过ContextImpl类来实现的。在<code>CI.sendBroadcast(Intent intent)</code>方法中，调用了<code>AMP.broadcastIntent()</code>，在<code>AMP.broadcastIntent()</code>中，通过<code>mRemote.transact()</code>方法，AMP通过Binder驱动将传递来的信息发送给system_server进程中的AMS对象，接下来进入到<code>AMS.broadcastIntent()</code>的执行过程中。</p>\n<p>  在<code>AMS.broadcastIntent()</code>方法中，通过传进来的两个布尔参数serialized和sticky来共同决定是普通广播， 有序广播,还是Sticky广播。在方法体中首先验证广播intent是否有效，获取调用者进程记录对象，接着调用<code>AMS.broadcastIntentLocked</code>。</p>\n<p>  在<code>AMS.broadcastIntentLocked</code>中首先需要设置广播 flag ,添加<code>flag=FLAG_EXCLUDE_STOPPED_PACKAGES</code>，保证已停止app不会收到该广播。当系统还没有启动完成，则不允许启动新进程，即只有动态注册 receiver 才能接受广播。当非USER_ALL广播且当前用户并没有处于Running的情况下，除非是系统升级广播或者关机广播，否则直接返回。</p>\n<p>  设置完flag之后进行广播权限验证，对于callingAppId为SYSTEM_UID，PHONE_UID，SHELL_UID，BLUETOOTH_UID，NFC_UID之一或者callingUid == 0时都畅通无阻。否则当调用者进程为空或者非persistent进程的情况下：</p>\n<ul>\n<li>当发送的是受保护广播mProtectedBroadcasts(只允许系统使用)，则抛出异常；</li>\n<li>当action为ACTION_APPWIDGET_CONFIGURE时，虽然不希望该应用发送这种广播，处于兼容性考虑，限制该广播只允许发送 给自己，否则抛出异常。</li>\n</ul>\n<p>  接着就是处理系统相关广播和增加sticky广播，将sticky广播增加到list，并放入mStickyBroadcasts里面。接下来查询receivers和registeredReceivers，当广播的intent没有设置FLAG_RECEIVER_REGISTERED_ONLY，则允许静态广播接收者来处理该广播，receivers记录着匹配当前intent的所有静态注册广播接收者。registeredReceivers记录着匹配当前的所有动态注册的广播接收者。</p>\n<p>  接着处理并行广播，处理并行广播主要是针对动态已注册的广播者，因此首先会获取到 registeredReceivers 中广播的数目。根据动态已注册的广播接受者的信息创建BroadcastRecord，将该BroadcastRecord加入到并行广播队列，在广播队列中有一个ArrayList类型的成员变量 mParallelBroadcasts 来维护所有的并行广播，然后接着调用 BroadcastQueue 的<code>scheduleBroadcastsLocked</code>方法来完成的不同广播的处理。</p>\n<p>  处理完并行广播之后，将 registerReceivers 合并到 receivers ，合并的过程中会比较优先级。合并完之后再 统一按串行方式处理，处理串行广播的过程中，也是先创建一个 BroadcastRecord 对象，然后将该 BroadcastRecord 对象加入到 有序广播队列中，在广播队列中有一个ArrayList类型的成员变量 mOrderedBroadcasts 来维护所有的有序广播同样的接着调 用 BroadcastQueue 的<code>scheduleBroadcastsLocked</code>方法来完成的不同广播的处理。</p>\n<h5 id=\"处理广播\">处理广播<a title=\"#处理广播\" href=\"#处理广播\"></a></h5>\n<p>  广播的处理是通过执行<code>scheduleBroadcastsLocked</code>方法来进行处理的。在该方法中，首先根据<code>mBroadcastsScheduled</code>来判断此时是否正在处理<code>BROADCAST_INTENT_MSG</code>消息，如果是，那么直接返回。否则，则通过 sendMessage 的方式来发送<code>BROADCAST_INTENT_MSG</code>消息，同时修改<code>mBroadcastsScheduled</code>的值为 true。在 BroadcastQueue 对象创建时，就会绑定一个 Looper 对象，接下来交由 mHandler 的<code>handleMessage</code>来处理。在<code>handleMessage</code>方法中，调用了<code>processNextBroadcast</code>方法。</p>\n<p>  首先处理并行广播，通过while循环, 一次性分发完所有的并发广播后,分发完成后则添加到历史广播队列。 分 发广播给已注册的 receiver 是通过调用<code>deliverToRegisteredReceiverLocked()</code>来实现的。下一步处理串行广播，首先会 获取所有该广播的接受者。同时如果广播处理时间超时，那么会强制结束这条广播。正常情况，继续往下通过调用<code>performReceiveLocked()</code>方法处理广播消息，处理完之后会取消<code>BROADCAST_TIMEOUT_MSG</code>消息。接着获取下条有序广播，在 这个过程中，首先设置广播超时时间，然后获取下一个广播接收者。如果该广播接收者是动态注册的，那么直接调用<code>deliverToRegisteredReceiverLocked()</code>方法来处理广播就好，对于静态注册的广播，会进行各种权限检测，权限不满足时会 设置<code>skip = true</code>，接着在后面会执行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (skip) &#123;</span><br><span class=\"line\">    r.receiver = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    r.curFilter = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    r.state = BroadcastRecord.IDLE;</span><br><span class=\"line\">    scheduleBroadcastsLocked();</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  接着处理下条有序广播，如果广播接受者所在进程已经运行，则调用方法<code>processCurBroadcastLocked(r, app)</code>直接处理，如果 receiver 所对应的进程尚未启动，则调用<code>startProcessLocked()</code>创建该进程，如果创建失败，那么结束该 receiver，同时重新调用<code>scheduleBroadcastsLocked()</code>，如果线程创建成功，则将重新将这个 BroadcastRecord 对象加入 到 mPendingBroadcast 中，以便下次处理有序广播时继续处理该对象。</p>\n<p>  在<code>deliverToRegisteredReceiverLocked</code>方法中，首先检查发送者是否有BroadcastFilter所需权限，以及接收者是否有发送者所需的权限等等，当权限都满足时，接着执行<code>performReceiveLocked()</code>方法。在这个方法里，通过binder 机制，通过<code>ATP.scheduleRegisteredReceiver()</code>向receiver 发送intent。ATP位于 system_server 进程，是 Binder Bp 端通过 Binder 驱动向 Binder Bn 端发送消息, ATP所对应的Bn 端位于发送广播调用端所在进程的 ApplicationThread， 即 进入<code>AT.scheduleRegisteredReceiver</code>，在该方法里继续调用<code>InnerReceiver.performReceive()</code>方法，在<code>performReceive()</code>方法里会调用<code>ReceiverDispatcher.performReceive()</code>，在<code>ReceiverDispatcher.performReceive()</code>方法里，首先会构造 参数 args。再通过 post() 的方式把消息放入 MessageQueue，再调用 Args 的 run() 方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Args</span> <span class=\"variable\">args</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Args</span>(intent, resultCode, data, extras, ordered, sticky, sendingUser);</span><br><span class=\"line\"><span class=\"comment\">//通过handler消息机制发送args.</span></span><br><span class=\"line\">mActivityThread.post(args)</span><br></pre></td></tr></table></figure>\n<p>  在 run() 方法中，便进入了主线程，最终调用 BroadcastReceiver 具体实现类的 onReceiver() 方法。最后会 执行<code>PengdingResult.finish()</code>方法。在 finish() 方法中，对于</p>\n<ul>\n<li>静态注册的广播接收者:\n<ul>\n<li>当 QueuedWork 工作未完成, 即 SharedPreferences 写入磁盘的操作没有完成, 则等待完成再执行 sendFinished 方法</li>\n<li>当 QueuedWork 工作已完成, 则直接调用 sendFinished 方法</li>\n</ul>\n</li>\n<li>动态注册的广播接收者:\n<ul>\n<li>当发送的是串行广播, 则直接调用 sendFinished 方法</li>\n</ul>\n</li>\n</ul>\n<p>  接着便是<code>sendFinished()</code>方法。在<code>sendFinished()</code>方法中，调用了<code>AMP.finishReceiver()</code>方法，最终通过 binder 的通信方式，进入<code>AMS.finishReceiver()</code>方法中，最终调用<code>BroadcastQueue.finishReceiverLocked()</code>方法以及调<br>\n用<code>processNextBroadcast</code>继续处理下一条广播。</p>\n","prev":{"title":"ContentProvider","link":"2018/02/12/ContentProvider"},"plink":"https://zhoufeichi.com/2018/02/09/Broadcast广播机制/","reward":true,"reading_time":"3183 words in 21 min"}