{"title":"Input系统之InputDisptcher线程","date":"2018-03-30T05:17:43.000Z","date_formatted":{"ll":"Mar 30, 2018","L":"03/30/2018","MM-DD":"03-30"},"link":"2018/03/30/Input系统之InputDisptcher线程","tags":["Android"],"categories":["笔记"],"updated":"2020-04-04T05:59:18.673Z","content":"<p>   InputReader 利用 EventHub 获取数据后生成 EventEntry 事件，加入到 InputDispatcher 的 mInboundQueue 队列，再唤醒 InputDispatcher 线程。InputDispatcher，同样从 threadLoop 为起点开始。<code>threadLoop()</code>中执行完<code>dispatchOnce()</code>之后会返回 Bool 类型的值。线程 Thread 类中有一个虚函数 <code>threadLoop()</code>，对于 Thread 的派生类 InputDispatcherThread 就实现了<code>threadLoop()</code>方法。事件的读取和派送过程是一直循环的，这就需要<code>threadLoop()</code>不断循环的执行。在 Thread 的<code>run()</code>方法中会实现创建线程的过程，在 Thread 类的<code>run()</code>方法执行后，会调用底层库 libpthread 的方法<code>pthread_create()</code>创建线程，并执行回调方法<code>_threadLoop()</code>。<code>_threadLoop()</code>便控制着<code>threadLoop()</code>的循环，这是在<code>_threadLoop()</code>方法中，有一个do while循环，每次执行完<code>threadLoop()</code>之后会记录<code>threadLoop()</code>的返回值，如果返回值不是 false ，那么便会一直循环执行<code>threadLoop()</code>。</p>\n<p>   InputDispatcher 对象在初始化的过程中，需要创建自己的 Looper 对象，然后获取分发超时参数，超时参数来自于 IMS ，参数默认值 keyRepeatTimeout = 500 ，keyRepeatDelay = 50。事件的分发是通过不断循环地调用 InputDispatcher 的<code>dispatchOnce()</code>来分发事件。在<code>dispatchOnce()</code>方法中，</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatchOnce</span>()</span><br><span class=\"line\">\t<span class=\"built_in\">dispatchOnceInnerLocked</span>(...)</span><br><span class=\"line\">\t\tmInboundQueue.<span class=\"built_in\">dequeueAtHead</span>()</span><br><span class=\"line\">\t\t<span class=\"built_in\">resetANRTimeoutsLocked</span>()</span><br><span class=\"line\">\t\t<span class=\"built_in\">dispatchKeyLocked</span>(...)</span><br><span class=\"line\">\t\t<span class=\"built_in\">dropInboundEventLocked</span>(...)</span><br><span class=\"line\">\t\t<span class=\"built_in\">releasePendingEventLocked</span>()</span><br><span class=\"line\">\t<span class=\"built_in\">runCommandsLockedInterruptible</span>()</span><br><span class=\"line\">\tmLooper-&gt;<span class=\"built_in\">pollOnce</span>(timeoutMillis)</span><br></pre></td></tr></table></figure>\n<p>  在<code>dispathOnceInnerLocked(...)</code>方法中，首先判断是否需要冻结事件分发工作不再执行，如果事件分发正常进行，判断事件分发的事件点距离该事件加入 mInboundQueue 的时间是否超过 500ms，超过500ms，则认为 app 切换过期，接下来就需要判断在 mInboundQueue 中是否有事件需要处理，如果没有需要处理的事件，那么会直接 return 返回。如果存在需要处理的事件，那么需要从 mInboundQueue 中取出头部的事件<code>mInboundQueue.dequeueAtHead()</code>，接着调用<code>resetANRTimeoutsLocked()</code>重置 ANR 信息。获取到需要处理的事件 mPendingEvent 之后，判断待处理事件的类型，根据不同的类型会相应的执行分发事件的操作，比如对于按键事件的分发则是通过<code>dispatchKeyLocked(...)</code>来实现的，分发动作完成之后会进行任务完成之后 done 的操作，首先需要判断是否需要丢弃事件，对于需要丢弃的事件，那么需要调用<code>dropInboundEventLocked(...)</code>来处理，最后还需要调用<code>releasePendingEventLocked()</code>释放当前正在处理的事件 mPendingEvent。在 dispatchKeyLocked 的分发事件执行完之后，</p>\n<ul>\n<li>不会执行 done 的情况:\n<ul>\n<li>当前 Event 时间小于唤醒时间</li>\n<li>让 policy 有机会执行拦截操作</li>\n<li>调用 findFocusedWindowTargetsLocked 方法的返回结果是 INPUT_EVENT_INJECTION_PENDING, 即 targets 没有处于 Ready 状态</li>\n</ul>\n</li>\n<li>会执行 done 的情况:\n<ul>\n<li>该事件需要丢弃，即 dropReason != DROP_REASON_NOT_DROPPED</li>\n<li>findFocusedWindowTargetsLocked 的返回结果不是 INPUT_EVENT_INJECTION_PENDING(没有正在处理的事件)</li>\n</ul>\n</li>\n</ul>\n<p>  在<code>dispatchKeyLocked()</code>方法中，会根据事件的 interceptKeyResult 的类型来进行不同的处理，如果 interceptKeyResult 的类型为<code>KeyEntry::INTERCEPT_KEY_RESULT_TRY_AGAIN_LATER</code>那么会进行唤醒时间的判断，如果当前时间小于唤醒时间，那么会进入等待状态，同时返回 false 。如果 interceptKetResult 的类型为<code>KeyEntry::INTERCEPT_KEY_RESULT_UNKNOWN</code>，那么就会让 policy 有机会执行拦截操作，同时也会返回 false 。如果需要丢弃该事件，需要执行清理操作，直接返回 true 。然后需要做的就是调用方法<code>findFocusedWindowTargetsLocked(...)</code>寻找焦点。如果寻找焦点失败，那么直接返回 false 。只有寻找焦点的结果 injectionResult 是成功的，那么才有机会真正的分发事件<code>dispatchEventLocked(...)</code>，因此可知，下列场景可能导致无法分发事件。</p>\n<ul>\n<li>当前时间小于唤醒时间</li>\n<li>policy 提前拦截事件</li>\n<li>需要 drop 事件的情况</li>\n<li>寻找聚焦窗口失败</li>\n</ul>\n<p>  如果不出现上述的这些情况，那么会正常进入事件分发的过程，在事件分发完成之后，也会正常进入前面提到的 Done 的处理过程，</p>\n","prev":{"title":"Input系统ANR总结","link":"2018/03/30/Input系统ANR总结"},"next":{"title":"Input系统之InputReader线程","link":"2018/03/30/Input系统之InputReader线程"},"plink":"https://zhoufeichi.com/2018/03/30/Input系统之InputDisptcher线程/","reward":true,"reading_time":"983 words in 7 min"}