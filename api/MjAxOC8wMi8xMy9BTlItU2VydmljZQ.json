{"title":"ANR-Service","date":"2018-02-13T03:13:35.000Z","date_formatted":{"ll":"Feb 13, 2018","L":"02/13/2018","MM-DD":"02-13"},"link":"2018/02/13/ANR-Service","tags":["Android","四大组件"],"categories":["笔记"],"updated":"2020-04-04T05:59:18.673Z","content":"<p>Service Timeout有两类:</p>\n<ul>\n<li>对于前台服务，则超时为SERVICE_TIMEOUT = 20s</li>\n<li>对于后台服务，则超时为SERVICE_BACKGROUND_TIMET = 200s</li>\n</ul>\n<h5 id=\"埋炸弹\">埋炸弹<a title=\"#埋炸弹\" href=\"#埋炸弹\"></a></h5>\n<p>  与 Service 相关的 ANR，埋炸弹阶段出现在<code>realStartServiceLocked()</code>方法中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">realStartServiceLocked</span><br><span class=\"line\">    bumpServiceExecutingLocked</span><br><span class=\"line\">        scheduleServiceTimeoutLocked</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  在<code>realStartServiceLocked</code>方法中先是通过<code>bumpServiceExecutingLocked</code>发送一个delay消息(SERVICE_TIMEOUT_MSG)。而在<code>bumpServiceExecutingLocked</code>中是通过调用<code>scheduleServiceTimeoutLocked</code>来实现的。<br>\n在<code>scheduleServiceTimeoutLocked</code>方法中，如果超时后依旧没有 remove 掉该 SERVICE_TIME_OUT 消息，那么会进入到service timeout流程。此时炸弹已经埋下，如果不希望炸弹被引爆，那么就需要在炸弹爆炸之前拆除炸弹。</p>\n<h5 id=\"拆炸弹\">拆炸弹<a title=\"#拆炸弹\" href=\"#拆炸弹\"></a></h5>\n<p>  拆炸弹的过程发生在目标进程的主线程调用<code>handleCreateService</code>的过程中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handleCreateService</span><br><span class=\"line\">    serviceDoneExecuting</span><br><span class=\"line\">        removeMessages</span><br></pre></td></tr></table></figure>\n<p>  在<code>handleCreateService</code>方法的处理过程中，会创建目标服务对象，以及回调onCreate方法，最后会执行<code>ActivityManagerNative.getDefault().serviceDoneExecuting</code>，这个过程是经过多次调用最后回到system server进程来执行 serviceDoneExecuting 以达到移除服务启动超时消息的目的。</p>\n<h5 id=\"引爆炸弹\">引爆炸弹<a title=\"#引爆炸弹\" href=\"#引爆炸弹\"></a></h5>\n<p>  如果没有在指定时间之内拆掉炸弹，那么炸弹爆炸后会导致ANR。当计时结束之后，system server 进程中名为ActivityManager 的 Handler 线程会收到 SERVICE_TIMEOUT_MSG 的消息，ActivityManager 通过 handler 的通信方式，将该 MSG 发送给 MainHandler 线程，MainHandler线程从消息队列中获得该消息，通过handleMessage 方法来进入serviceTimeout过程，最终便是调用<code>appNotResponding(...)</code>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handleMessage(...)</span><br><span class=\"line\">    AS.serviceTimeout(...)</span><br><span class=\"line\">        AMS.appNotResponding(...)</span><br></pre></td></tr></table></figure>\n<p>  Service 运行在主线程里面，在 Service 里编写了非常耗时的代码会出现 ANR。可以在 Service 中再创建一个子线程，然后在这里去处理耗时逻辑，或者使用远程Service的方式。但是在使用远程Service的方式的时候，Service 和 Activity 不在同一个进程，这个时候，不能通过传统的方式来建立关联，需要使用 AIDL 来进行跨进程通信。远程服务是独立的进程，进程名格式为所在包名你指定的<code>android:process</code>字符串。</p>\n","prev":{"title":"ANR-Broadcast","link":"2018/02/24/ANR-Broadcast"},"next":{"title":"Binder通信","link":"2018/02/12/Binder通信"},"plink":"https://zhoufeichi.com/2018/02/13/ANR-Service/","reward":true}