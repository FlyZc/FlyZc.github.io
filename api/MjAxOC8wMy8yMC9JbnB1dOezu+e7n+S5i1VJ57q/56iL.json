{"title":"Input系统之UI线程","date":"2018-03-20T06:05:36.000Z","date_formatted":{"ll":"Mar 20, 2018","L":"03/20/2018","MM-DD":"03-20"},"link":"2018/03/20/Input系统之UI线程","tags":["Android"],"categories":["笔记"],"updated":"2020-04-04T05:59:18.673Z","content":"<p>   InputReader 和 InputDispatcher 运行在 system_server 进程，用户点击的界面往往可能是某个 app 。而每个 app 运行在自己的进程，这就涉及到跨进程之间的通信，也就是 app 进行和 system 进程建立通信。</p>\n<p>   Activity 会对应一个应用窗口，每个应用窗口对应一个 ViewRootImpl 。在 Activity 启动时，会调用到<code>Activity.onCreate(...)</code>方法，在<code>onCreate(...)</code>方法中，会再调用<code>setContentView(...)</code>，这涉及到 AMS 和 WMS 的各种交互，再往下走最终会调用<code>WindowManagerGlobal.addView(...)</code>方法。在<code>addView(...)</code>方法中，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addView(...)</span><br><span class=\"line\">\t<span class=\"type\">ViewRootImpl</span> <span class=\"variable\">root</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ViewRootImpl</span>(...)</span><br><span class=\"line\">\troot.setView(...)</span><br></pre></td></tr></table></figure>\n<p>  在 创建 ViewRootImpl 的对象时，首先会通过<code>WindowManagerGlobal.getWindowSession()</code>获取 IWindowSession 的代理类，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getWindowSession()</span><br><span class=\"line\">\t<span class=\"comment\">//获取 IMS 的代理类</span></span><br><span class=\"line\">\t<span class=\"type\">InputMethodManager</span> <span class=\"variable\">imm</span> <span class=\"operator\">=</span> InputMethodManager.getInstance()</span><br><span class=\"line\">\t<span class=\"comment\">//获取WMS的代理类</span></span><br><span class=\"line\">\t<span class=\"type\">IWindowManager</span> <span class=\"variable\">windowManager</span> <span class=\"operator\">=</span> getWindowManagerService()</span><br><span class=\"line\">\t<span class=\"comment\">//经过Binder调用，最终调用WMS</span></span><br><span class=\"line\">\tsWindowSession = windowManager.openSession(..., imm.getClient(), imm.getInputContext())</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sWindowSession</span><br></pre></td></tr></table></figure>\n<p>  在这个过程中， Session 对象创建好了之后，会通过 Binder 将数据写回 app 进程，那么 app 进程便获得了 Session 的代理对象。接下类就是<code>setView(...)</code>的过程，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setView(...)</span><br><span class=\"line\">\tmInputChannel = <span class=\"keyword\">new</span> <span class=\"title class_\">InputChannel</span>(); <span class=\"comment\">//创建InputChannel对象</span></span><br><span class=\"line\">\tres = mWindowSession.addToDisplay(...)</span><br><span class=\"line\">\tmInputEventReceiver = <span class=\"keyword\">new</span> <span class=\"title class_\">WindowInputEventReceiver</span>(...)</span><br></pre></td></tr></table></figure>\n<p>  创建好的 mInputChannel 对象会作为参数传入<code>mWindowSession.addToDislplay(...)</code>方法中，这也是通过 Binder 的通信方式，最终调用的是<code>mService.addWindow(...)</code>方法，在<code>WMS.addWindow(...)</code>方法中，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">WindowState</span> <span class=\"variable\">win</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">WindowState</span>(...)</span><br><span class=\"line\"><span class=\"comment\">//根据WindowState的HashCode以及title来生成InputChannel名称</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> win.makeInputChannelName()</span><br><span class=\"line\"><span class=\"comment\">//创建一对InputChannel</span></span><br><span class=\"line\">InputChannel[] inputChannels = InputChannel.openInputChannelPair(name)</span><br><span class=\"line\"><span class=\"comment\">//将socket服务端保存到WindowState的mInputChannel</span></span><br><span class=\"line\">win.setInputChannel(inputChannels[<span class=\"number\">0</span>])\t\t\t\t        </span><br><span class=\"line\"><span class=\"comment\">//socket客户端传递给outInputChannel</span></span><br><span class=\"line\">inputChannels[<span class=\"number\">1</span>].transferTo(outInputChannel)</span><br><span class=\"line\"><span class=\"comment\">//利用socket服务端作为参数</span></span><br><span class=\"line\">mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle)</span><br><span class=\"line\"><span class=\"comment\">//设置当前聚焦窗口\t</span></span><br><span class=\"line\">mInputMonitor.updateInputWindowsLw(<span class=\"literal\">false</span> <span class=\"comment\">/*force*/</span>)</span><br></pre></td></tr></table></figure>\n<p>  在创建 InputChannels 数组的过程中，首先是创建两个 socket 对象，创建两个 InputChannel 对象，socket 对象会分别和两个 InputChannel 对象绑定，创建两个 NativeInputChannel 对象之后，nativeInputChannel 对象会跟 InputChannel 对象绑定在一起，即将 nativeInputChannel 保存到 java 层的 InputChannel 的成员变量 mPtr 。最后需要做的事情就是将 client 和 server 插入到 channelPair 中，得到的 channelPair 会返回给 inputChannels 数组。</p>\n<p>  得到 inputChannels 数组之后，inputChannels[0] 对应的是服务端，而 inputChannels[1] 对应的是客户端，在这里将服务端<br>\n保存在 WindowState 的 mInputChannel 中，客户端传送给 outInputChannel 对象，而这个 outInputChannel 正是作为参数传递过来的 App 进程中 ViewRootImpl 的 mInputChannel。</p>\n","prev":{"title":"Input系统之InputReader线程","link":"2018/03/30/Input系统之InputReader线程"},"next":{"title":"Input 系统启动","link":"2018/03/14/Input系统之启动过程"},"plink":"https://zhoufeichi.com/2018/03/20/Input系统之UI线程/","reward":true,"reading_time":"614 words in 4 min"}