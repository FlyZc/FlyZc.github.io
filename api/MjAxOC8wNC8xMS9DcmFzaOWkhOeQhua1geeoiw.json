{"title":"Crash处理流程","date":"2018-04-11T06:23:39.000Z","date_formatted":{"ll":"Apr 11, 2018","L":"04/11/2018","MM-DD":"04-11"},"link":"2018/04/11/Crash处理流程","tags":["Android"],"categories":["笔记"],"updated":"2022-01-25T02:59:30.293Z","content":"<p>  我们通常使用<code>try...catch</code>语句来捕获异常，对于没有有效的<code>catch exception</code>，就会导致应用 crash ，当出现 exception 没有 catch 的情况，系统便会来进行捕获，并进入 crash 流程。在进程创建之初会设置未捕获异常的处理器，当系统抛出未捕获的异常时，最终都交给异常处理器。进程创建过程中，会调用<code>RuntimeInit.java</code>的<code>commonInit()</code>方法设置 KillApplicationHandler , 用于处理未捕获异常。</p>\n<p>  在<code>RuntimeInit</code>类中的<code>commonInit()</code>方法中，通过<code>Thread.setDefaultUncaughtExceptionHandler(new KillApplicationHandler())</code>将异常处理器 handler 对象赋给 Thread 成员变量,在 KillApplicationHandler 类中，复写了<code>uncaughtException(...)</code>方法，在<code>uncaughtException(...)</code>方法中，会根据进程类型，分别打印对应的 FATAL EXCEPTION 信息，接着会启动 crash 对话框<code>ActivityManager.getService.handleApplicationCrash(mApplicationObject, new ApplicationErrorReport.ParcelableCrashInfo(e))</code>，等待处理完成。AMP 经过 binder 调用最终交给 ActivityManagerService 中相应的方法去处理，故接下来调用的是<code>AMS.handleApplicationCrash()</code>。在 CrashInfo 对象中，会封装好 crash 信息文件名，类名，方法名，对应行号以及异常信息，同时会输出栈 trace 。</p>\n<p>  在 AMS 的<code>handleApplicationCrash(...)</code>中，首先需要获取进程 record 对象，根据获取到的对象来获取进程名，此时有几种情况：</p>\n<ul>\n<li>当远程IBinder对象为空时，则进程名为system_server</li>\n<li>当远程IBinder对象不为空，且ProcessRecord为空时，则进程名为unknown</li>\n<li>当远程IBinder对象不为空，且ProcessRecord不为空时，则进程名为ProcessRecord对象中相应进程名</li>\n</ul>\n<p>  获取到进程名之后，会进入到方法<code>handleApplicationCrashInner(...)</code>方法的执行过程当中。在这个方法中，会将 Crash 信息写入到 EventLog 中，将错误信息添加到 DropBox 中，将错误信息添加到 DropBox 其实是将 crash 信息输出到目录 /data/system/dropbox 。例如 system_server 的 dropbox 文件名为 system_server_crash@xxx.txt (xxx代表的是时间戳)。接下来就需要执行<code>crashApplication(...)</code>方法。</p>\n<p>   <code>crashApplication(...)</code>是 AppErrors 类中的方法，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AppErrors.crashApplication(...)</span><br><span class=\"line\">    AppErrors.crashApplicationInner(...)</span><br><span class=\"line\">        AppErrors.makeAppCrashingLocked(...)</span><br></pre></td></tr></table></figure>\n<p>  调用了<code>makeAppCrashingLocked(...)</code>来继续处理 crash 流程，还需要做的事情就是发送消息 SHOW_ERROR_MSG ，弹出提示 crash 的对话框，等待用户选择。进入到<code>makeAppCrashingLocked(...)</code>方法的执行过程中，需要做的事情就是先把 crash 信息封装到 crashingReport 对象中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">makeAppCrashingLocked(...)</span><br><span class=\"line\">    app.crashingReport = generateProcessError(...)</span><br><span class=\"line\">    startAppProblemLocked(app)</span><br><span class=\"line\">    app.stopFreezingAllLocked()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> handleAppCrashLocked(...)</span><br></pre></td></tr></table></figure>\n<p>  那么在<code>startAppProblemLocked(app)</code>方法中，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">startAppProblemLocked(app)</span><br><span class=\"line\">    app.errorReportReceiver = ApplicationErrorReport.getErrorReportReceiver(...)</span><br><span class=\"line\">    skipCurrentReceiverLocked(app)</span><br></pre></td></tr></table></figure>\n<p>  会获取当前用户下的 crash 应用的 error receiver，然后会忽略当前 app 的广播接收。在忽略当前 app 的广播接收过程中，其实是针对每个广播队列，都会执行对应队列的<code>skipCurrentReceiverLocked(app)</code>方法来结束 app 进程对应的广播的接收。</p>\n<p>  在<code>startAppProblemLocked(app)</code>执行完了之后，便会执行<code>stopFreezingAllLocked()</code>来执行停止屏幕冻结的操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ProcessRecord.stopFreezingAllLocked()</span><br><span class=\"line\">    activities.get(i).stopFreezingScreenLocked(force:<span class=\"literal\">true</span>)  <span class=\"comment\">//ActivityRecord.stopFreezingScreenLocked</span></span><br><span class=\"line\">    service.mWindowManager.stopFreezingScreen(appToken, force)  <span class=\"comment\">//WMS.stopFreezingScreen</span></span><br><span class=\"line\">    WMS.stopFreezingDisplayLocked()</span><br></pre></td></tr></table></figure>\n<p>  在<code>WMS.stopFreezingDisplayLocked()</code>方法中，做的事情包括:</p>\n<ul>\n<li>处理屏幕旋转相关逻辑</li>\n<li>移除冻屏的超时消息</li>\n<li>屏幕旋转动画的相关操作</li>\n<li>使能输入事件分发功能</li>\n<li>display冻结时，执行gc操作</li>\n<li>更新当前的屏幕方向</li>\n<li>向 mH 发送 configuration 改变的消息</li>\n</ul>\n<p>  到此处<code>stopFreezingAllLocked()</code>方法执行结束，接下来就是需要执行<code>handleAppCrashLocked(...)</code>方法，在该方法中，主要的执行逻辑如下:</p>\n<ul>\n<li>当同一进程在时间间隔小于1分钟时连续两次 crash，则执行的情况如下：\n<ul>\n<li>对于非persistent进程：\n<ul>\n<li>mStackSupervisor.handleAppCrashLocked(app)</li>\n<li>removeProcessLocked(app, false, false, “crash”)</li>\n<li>mStackSupervisor.resumeTopActivitiesLocked()</li>\n</ul>\n</li>\n<li>对于persistent进程，则只执行\n<ul>\n<li>mStackSupervisor.resumeTopActivitiesLocked()</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>否则执行\n<ul>\n<li>mStackSupervisor.finishTopRunningActivityLocked(app, reason)</li>\n</ul>\n</li>\n</ul>\n<p>  在方法<code>ActivityStackSupervisor.handleAppCrashLocked(app)</code>中，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ASS.handleAppCrashLocked(app)</span><br><span class=\"line\">ActivityStack.handleAppCrashLocked(app)</span><br></pre></td></tr></table></figure>\n<p>  这个方法的目的就是用来结束当前 activity ，在方法体内，通过遍历 stack 中 task ，获取到 task 中的所有 activity ，遍历所有 activities ，找到位于该 ProcessRecord 的所有 ActivityRecord ，通过调用<code>finishCurrentActivityLocked(...)</code>方法来结束该 activity 。</p>\n<p>  下一步会执行<code>AMS.removeProcessLocked(...)</code>方法，在该方法中，首先会从 mProcessNames 中移除该进程，还需要通过<code>app.kill()</code>进行杀进程的操作，移除进程并清空该进程相关联的 activity/service 等组件。此处 mProcessNames 数据类型为 ProcessMap，这是以进程名为 key，记录着所有的ProcessRecord 信息。移除进程并清空该进程相关联的 activity/service 等组件是通过<code>AMS.handleAppDiedLocked()</code>来处理，主要包括清除应用中的 activity/service/receiver/ContentProvider 信息。</p>\n<p>  下一步就是执行<code>ASS.resumeTopActivitiesLocked()</code>，该方法执行完，就完成了 activity 的 resume 的过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ASS.resumeTopActivitiesLocked()</span><br><span class=\"line\">    AS.resumeTopActivityLocked()</span><br><span class=\"line\">        As.resumeTopActivityInnerLocked()</span><br></pre></td></tr></table></figure>\n<p>  针对另一种情况，在执行<code>ASS.finishTopRunningActivityLocked(...)</code>方法的时候，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ASS.finishTopRunningActivityLocked(...)</span><br><span class=\"line\">    stack.finishTopRunningActivityLocked(app, reason)</span><br><span class=\"line\">    AS.finishActivityLocked(...)</span><br></pre></td></tr></table></figure>\n<p>  在这个方法中，最终会回调到 activity 的 pause 方法。最后处理完<code>makeAppCrashingLocked(...)</code>方法，则会再发送消息 SHOW_ERROR_MSG ，弹出提示 crash 的对话框。处理 SHOW_ERROR_MSG 的消息则是 UiHandler 通过 handleMessage 来完成的。系统会弹出提示 crash 的对话框，并阻塞等待用户选择是“退出”或 “退出并报告”，当用户不做任何选择时 5min 超时后，默认选择“退出”，当手机休眠时也默认选择“退出”。到这里，最后在 uncaughtException 中在 finally 语句块还有一个杀进程的动作，通过 finally 语句块中执行<code>Process.killProcess(...)</code>来保证彻底杀掉 crash 进程。</p>\n<p>  最后还有一个 Binder 的死亡回调过程，在应用进程创建的过程中有一个<code>attachApplicationLocked()</code>方法的过程中便会创建死亡通知。当 binder 服务端挂了之后，便会通过 binder 的 DeathRecipient 来通知 AMS 进行相应的清理收尾工作。前面讲到 crash 的进程会被 kill 掉，那么当该进程被杀，则会回调到<code>binderDied()</code>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AMS.binderDied()</span><br><span class=\"line\">    AMS.appDiedLocked()</span><br><span class=\"line\">        AMS.handleAppDiedLocked(...)</span><br><span class=\"line\">            AMS.cleanUpApplicationRecordLocked(...)  <span class=\"comment\">//清理应用程序service, BroadcastReceiver, ContentProvider相关信息</span></span><br><span class=\"line\">                app.activities.clear()  <span class=\"comment\">//清理 activity 相关信息</span></span><br></pre></td></tr></table></figure>\n<p>  清理 ContentProvider 的过程，首先获取该进程已发表的 ContentProvider ，将 DyingProvider 清理掉，这包括 ContentProvider 的服务端和客户端都会被杀。还需要处理的就是正在启动并且有客户端正在等待的 ContentProvider 。最后就是取消已连接的 ContentProvider 的注册。清理 BroadcastReceiver 主要就是取消注册的广播接收者。</p>\n<p>  当 crash 进程执行 kill 操作后，进程被杀。由于 crash 进程中拥有一个 Binder 服务端 ApplicationThread ，而应用进程在创建过程调用<code>attachApplicationLocked()</code>，从而 attach 到 system_server 进程，在 system_server 进程内有一个 ApplicationThreadProxy ，这是相对应的 Binder 客户端。当 Binder 服务端 ApplicationThread 所在进程(即 crash 进程)挂掉后，则 Binder 客户端能收到相应的死亡通知，从而进入 binderDied 流程。</p>\n","prev":{"title":"常用快捷键记录","link":"2018/06/14/Key"},"next":{"title":"亮灭屏流程","link":"2018/04/03/亮灭屏流程"},"plink":"https://zhoufeichi.com/2018/04/11/Crash处理流程/","reward":true,"reading_time":"1692 words in 11 min"}