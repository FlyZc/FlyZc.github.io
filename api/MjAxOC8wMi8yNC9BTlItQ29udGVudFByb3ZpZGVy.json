{"title":"ANR-ContentProvider","date":"2018-02-24T06:09:58.000Z","date_formatted":{"ll":"Feb 24, 2018","L":"02/24/2018","MM-DD":"02-24"},"link":"2018/02/24/ANR-ContentProvider","tags":["Android","四大组件"],"categories":["笔记"],"updated":"2020-04-04T05:59:18.673Z","content":"<p>   当 ActivityManager 线程中的 AMS.MainHandler 收到 CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG 消息时会触发 ContentProvider Timeout 事件。ContentProvider 超时与 Provider 进程启动过程相关， CONTENT_PROVIDER_PUBLISH_TIMEOUT = 10s。</p>\n<h4 id=\"埋炸弹\">埋炸弹<a title=\"#埋炸弹\" href=\"#埋炸弹\"></a></h4>\n<p>  在 Provider 启动的过程中，埋炸弹会发生在进程创建的阶段，进程创建后会调用<code>AMS.attachApplicationLocked()</code>进入 system_server 进程。在<code>AMS.attachApplicationLocked()</code>方法中，app 进程存在正在启动中的 provider ,则超时10s后发送 CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG 消息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (providers != <span class=\"literal\">null</span> &amp;&amp; checkAppInLaunchingProvidersLocked(app)) &#123;</span><br><span class=\"line\">    <span class=\"type\">Message</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);</span><br><span class=\"line\">    msg.obj = app;</span><br><span class=\"line\">    mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"拆炸弹\">拆炸弹<a title=\"#拆炸弹\" href=\"#拆炸弹\"></a></h4>\n<p>  当 provider 通过<code>AMS.publishContentProviders(...)</code>成功 publish 之后,便会通过<code>mHandler.removeMessages(...)</code>拆除该炸弹。</p>\n<h4 id=\"引爆炸弹\">引爆炸弹<a title=\"#引爆炸弹\" href=\"#引爆炸弹\"></a></h4>\n<p>  在前面埋炸弹的过程，会通过<code>mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT)</code>来发送一个超时消息，那么在倒计时结束后便会向 system_server 进程中名为 ActivityManager 的 handler 线程发送 CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG 消息。该线程通过<code>handleMessage(...)</code>的方式，来处理超时消息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handleMessage(...)</span><br><span class=\"line\">    AMS.processContentProviderPublishTimedOutLocked(...)</span><br><span class=\"line\">        AMS.cleanupAppInLaunchingProvidersLocked(...)</span><br><span class=\"line\">            AMS.removeDyingProviderLocked(...)</span><br><span class=\"line\">        AMS.removeProcessLocked(...)</span><br></pre></td></tr></table></figure>\n<p>  <code>removeDyingProviderLocked()</code>方法的作用是移除死亡的 provider，在处理的过程中跟 provider 的类型有关：</p>\n<ul>\n<li>对于 stable 类型的 provider (即conn.stableCount &gt; 0),则会杀掉所有跟该 provider 建立 stable 连接的非 persistent 进程</li>\n<li>对于 unstable 类型的 provider (即conn.unstableCount &gt; 0),并不会导致 client 进程被级联所杀</li>\n</ul>\n<p>  对于 Service, Broadcast 发生 ANR 之后,最终都会调用 AMS.appNotResponding 。对于 provider ,在其进程启动时 publish 过程可能会出现 ANR, 则会直接杀进程以及清理相应信息,而不会弹出 ANR 的对话框。</p>\n","prev":{"title":"Git使用总结","link":"2018/03/11/Git"},"next":{"title":"ANR-Broadcast","link":"2018/02/24/ANR-Broadcast"},"plink":"https://zhoufeichi.com/2018/02/24/ANR-ContentProvider/","reward":true}